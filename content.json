{"pages":[{"title":"404","text":"","path":"404/index.html","date":"01-15","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-15","excerpt":""},{"title":"关于我","text":"毕业于jxufe，大学期间是软件工程专业。一心想着读CS，目前正在准备考研。","path":"about/index.html","date":"01-15","excerpt":""}],"posts":[{"title":"codeforces2","text":"A. WinnerThe winner of the card game popular in Berland “Berlogging” is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line “name score”, where name is a player’s name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to m) at the end of the game, than wins the one of them who scored at least m points first. Initially each player has 0 points. It’s guaranteed that at the end of the game at least one player has a positive number of points. Input The first line contains an integer number n (1 ≤ n ≤ 1000), n is the number of rounds played. Then follow n lines, containing the information about the rounds in “name score” format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive. Output Print the name of the winner. Examples input 3 mike 3 andrew 5 mike 2 output andrew input 3 andrew 3 andrew 2 mike 5 output andrew 题意给出n组人名，分数，求最后分数最高的人，如果有多人，就输出最早达到或超过最高分的人。 思路n不大，就记录输入的顺序，先求一遍最后分，得到最大分，最后模拟一遍输入，求到最先得到或超过最高分的人。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const int MAX = 1010;int n;string s[MAX];int cnt[MAX];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; map&lt;string, int&gt; mp; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i] &gt;&gt; cnt[i]; mp[s[i]] += cnt[i]; &#125; int ma = 0; for (auto it = mp.begin(); it != mp.end(); it++) &#123; ma = max(ma, it-&gt;second); &#125; map&lt;string, int&gt; mp2; for (int i = 0; i &lt; n; i++) &#123; mp2[s[i]] += cnt[i]; if (mp[s[i]] == ma &amp;&amp; mp2[s[i]] &gt;= ma) &#123; cout &lt;&lt; s[i] &lt;&lt; endl; break; &#125; &#125; return 0;&#125;","path":"2019/01/19/codeforces2/","date":"01-19","excerpt":"","tags":[{"name":"模拟","slug":"模拟","permalink":"/tags/模拟/"}]},{"title":"Emacs学习day2","text":"简单的分屏操作 C-x 1 仅保留当前窗口 C-x 2 将当前窗口分到上边 C-x 3 将当前窗口分到右边 更多操作：https://www.gnu.org/software/emacs/manual/html_node/emacs/Split-Window.html Emacs插件源使用MELPA源 一些简单的配置，使用SpaceEmacs Rocks day2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647(when (&gt;= emacs-major-version 24) (require 'package) (package-initialize) (setq package-archives '((\"gnu\" . \"http://elpa.emacs-china.org/gnu/\") (\"melpa\" . \"http://elpa.emacs-china.org/melpa/\"))));; 注意 elpa.emacs-china.org 是 Emacs China 中文社区在国内搭建的一个 ELPA 镜像 ;; cl - Common Lisp Extension (require 'cl) ;; Add Packages (defvar my/packages '( ;; --- Auto-completion --- company ;; --- Better Editor --- hungry-delete swiper counsel smartparens ;; --- Major Mode --- js2-mode ;; --- Minor Mode --- nodejs-repl exec-path-from-shell ;; --- Themes --- monokai-theme ;; solarized-theme ) \"Default packages\") (setq package-selected-packages my/packages) (defun my/packages-installed-p () (loop for pkg in my/packages when (not (package-installed-p pkg)) do (return nil) finally (return t))) (unless (my/packages-installed-p) (message \"%s\" \"Refreshing package database...\") (package-refresh-contents) (dolist (pkg my/packages) (when (not (package-installed-p pkg)) (package-install pkg)))) ;; Find Executable Path on OS X (when (memq window-system '(mac ns)) (exec-path-from-shell-initialize)) 一些其它的配置 12345678;; 高亮当前行(global-hl-line-mode 1);; 默认全屏(setq initial-frame-alist (quote ((fullscreen . maximized))));; 匹配括号(add-hook 'emacs-lisp-mode-hook 'show-paren-mode) auto-mode-list匹配Major Mode使用正则表达式匹配Major Mode 123456789(setq auto-mode-alist (append ;; File name (within directory) starts with a dot. '((\"/\\\\.[^/]*\\\\'\" . fundamental-mode) ;; File name has no dot. (\"/[^\\\\./]*\\\\'\" . fundamental-mode) ;; File name ends in ‘.C’. (\"\\\\.C\\\\'\" . c++-mode)) auto-mode-alist))","path":"2019/01/18/Emacs学习day2/","date":"01-18","excerpt":"","tags":[{"name":"emacs","slug":"emacs","permalink":"/tags/emacs/"}]},{"title":"codeforces1","text":"A. Theatre SquareTheatre Square in the capital city of Berland has a rectangular shape with the size n × m meters. On the occasion of the city’s anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size a × a. What is the least number of flagstones needed to pave the Square? It’s allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It’s not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square. Input The input contains three positive integer numbers in the first line: n, m and a (1 ≤ n, m, a ≤ 109). Output Write the needed number of flagstones. Examples input 6 6 4 output 4 题意 n × m 的剧院，要用 a ×a 的石板铺满，石板要和剧院的边界平行，石板不能切割，但铺盖的范围可以超过剧院的边界。求最少用多少块石板。 思路从剧院的左上角开始铺，直到刚好铺满一行或刚好超过，可知每行铺$ \\left \\lceil \\frac{m}{a} \\right \\rceil $，同理每列铺$\\left \\lceil \\frac{n}{a} \\right \\rceil$。 代码12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll n, m, a;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%lld %lld %lld\", &amp;n, &amp;m, &amp;a); printf(\"%lld\\n\", (ll)ceil(1.0 * n / a) * (ll)ceil(1.0 * m / a)); return 0;&#125; B. SpreadsheetsIn the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc. The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example. Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system. Input The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 . Output Write n lines, each line should contain a cell coordinates in the other numeration system. Examples input 2 R23C55 BC23 output BC23 R23C55 题意对输入的格式进行转换，将(R, C)的形式转换成A-Z的列表示+数字的行表示，将A-Z的列表示+数字的行表示转换成(R,C)的形式 思路纯模拟题，先扫描输入的字符串，看有多少个数字部分，1，2分别对应两种格式，创造数字字符串转换成整型的函数，A-Z的字符串转换成整型的函数，整型转换成A-Z的字符串函数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int MAX_N = 1000010;char s[MAX_N];int len, n, num, p;int str2num(char ss[], int &amp;p) &#123; int ans = 0; while (ss[p] != '\\0' &amp;&amp; isdigit(ss[p])) &#123; ans *= 10; ans += ss[p] - '0'; p++; &#125; return ans;&#125;void num2ABC(int dig) &#123; int tmp[10000]; int tlen = 0; while (dig) &#123; int t = dig % 26; if (t == 0) &#123; tmp[tlen++] = 26; dig = dig / 26 - 1; &#125; else &#123; tmp[tlen++] = t; dig = dig / 26; &#125; &#125; for (int i = tlen-1; i &gt;= 0; i--) &#123; printf(\"%c\", 'A'+tmp[i]-1); &#125;&#125;int ABC2num(char ss[], int &amp;p) &#123; int ans = 0; while (ss[p] != '\\0' &amp;&amp; isalpha(ss[p])) &#123; ans *= 26; ans += ss[p] - 'A' + 1; p++; &#125; return ans;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;n); while (n--) &#123; scanf(\"%s\", s); len = strlen(s); num = 0; p = 0; for (int i = 1; i &lt; len; i++) &#123; if (isalpha(s[i-1]) &amp;&amp; isdigit(s[i])) &#123; num++; &#125; &#125; if (num == 1) &#123; p = 0; int b = ABC2num(s, p); int a = str2num(s, p); printf(\"R%dC%d\\n\", a, b); &#125; else if (num == 2) &#123; p = 1; int a = str2num(s, p); p++; int b = str2num(s, p); num2ABC(b); printf(\"%d\\n\", a); &#125; &#125; return 0;&#125; C. Ancient Berland CircusNowadays all circuses in Berland have a round arena with diameter 13 meters, but in the past things were different. In Ancient Berland arenas in circuses were shaped as a regular (equiangular) polygon, the size and the number of angles could vary from one circus to another. In each corner of the arena there was a special pillar, and the rope strung between the pillars marked the arena edges. Recently the scientists from Berland have discovered the remains of the ancient circus arena. They found only three pillars, the others were destroyed by the time. You are given the coordinates of these three pillars. Find out what is the smallest area that the arena could have. Input The input file consists of three lines, each of them contains a pair of numbers –– coordinates of the pillar. Any coordinate doesn’t exceed 1000 by absolute value, and is given with at most six digits after decimal point. Output Output the smallest possible area of the ancient arena. This number should be accurate to at least 6 digits after the decimal point. It’s guaranteed that the number of angles in the optimal polygon is not larger than 100. Examples input 0.000000 0.000000 1.000000 1.000000 0.000000 1.000000 output 1.00000000 题意给出正多边形的三个顶点，求此多边形的最小面积 思路3个顶点可以确定此多边形的中心就是这个三角形的外心，易知正n边形中n越小则面积越小，求三角形外心以及三个顶点中的两个组成圆心角的最大公约数，再用2PI除以其最大公约数就可以得到n 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const double EPS = 1e-4;const double PI = acos(-1.0);struct Point &#123; double x, y; void read() &#123; scanf(\"%lf %lf\", &amp;x, &amp;y); &#125;&#125;;double dis(Point p1, Point p2) &#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y));&#125;double gcd(double x, double y) &#123; return y &gt; EPS ? gcd(y, x-floor(x/y)*y) : x;&#125;double getTheta(double a, double b, double c) &#123; return acos((a * a + b * b - c * c) / (2 * a * b));&#125;Point p1, p2, p3;double d1, d2, d3, p, s, r, theta1, theta2, theta3, n, theta, ans;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); p1.read(); p2.read(); p3.read(); d1 = dis(p1, p2); d2 = dis(p1, p3); d3 = dis(p2, p3); p = (d1 + d2 + d3) / 2.0; s = sqrt(p * (p-d1) * (p-d2) * (p - d3)); r = (d1 * d2 * d3) / (4.0 * s); theta1 = getTheta(r, r, d3); theta2 = getTheta(r, r, d2); theta3 = 2 * PI - theta1 - theta2; theta = (gcd(theta1, gcd(theta2, theta3))); n = PI / theta; ans = n * r * r * sin(theta); printf(\"%.6lf\\n\", ans); return 0;&#125;","path":"2019/01/16/codeforces1/","date":"01-16","excerpt":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"/tags/codeforces/"},{"name":"数学","slug":"数学","permalink":"/tags/数学/"},{"name":"模拟","slug":"模拟","permalink":"/tags/模拟/"},{"name":"计算几何","slug":"计算几何","permalink":"/tags/计算几何/"}]},{"title":"Emacs学习day1","text":"学习emacs tutorialemacs tutorial中有一些常用的emacs操作，学习emacs中的一些函数操作之前先把一些基本的光标操作过一遍。 打开emacs tutorial的方式 直接点击emacs tutorial 输入C-h t 基本操作文件（buffer）操作 C-x C-c 关闭emacs（不保存） C-x C-f 打开文件 C-x C-s 保存 光标操作 C-f 为前移一个字符， f 代表 forward。 C-b 为后移一个字符， b 代表 backward。 C-p 为上移至前一行， p 代表 previous。 C-n 为上移至下一行， n 代表 next。 C-a 为移至行首， a 代表 ahead。 C-e 为移至行尾， e 代表 end。 帮助快捷键 C-h k 寻找快捷键的帮助信息 C-h v 寻找变量的帮助信息 C-h f 寻找函数的帮助信息 Elisp学习链接：https://learnxinyminutes.com/docs/elisp/ 编辑器配置配置文件emacs的配置文件默认路径是~/.emacs.d/init.el 基本配置配置直接用了Spacemacs Rocks中day1的配置，链接：http://book.emacs-china.org/ 1234567891011121314151617181920212223242526272829;; 关闭工具栏，tool-bar-mode 即为一个 Minor Mode(tool-bar-mode -1);; 关闭文件滑动控件(scroll-bar-mode -1);; 显示行号(global-linum-mode 1);; 更改光标的样式（不能生效，解决方案见第二集）(setq cursor-type 'bar);; 关闭启动帮助画面(setq inhibit-splash-screen 1);; 关闭缩进 (第二天中被去除);; (electric-indent-mode -1);; 更改显示字体大小 16pt;; http://stackoverflow.com/questions/294664/how-to-set-the-font-size-in-emacs(set-face-attribute 'default nil :height 160);; 快速打开配置文件(defun open-init-file() (interactive) (find-file \"~/.emacs.d/init.el\"));; 这一行代码，将函数 open-init-file 绑定到 &lt;f2&gt; 键上(global-set-key (kbd \"&lt;f2&gt;\") 'open-init-file) mode的区别emacs中有两种mode major mode minor mode 其中major mode一个文件只能有一个，minor mode能有[0, n]个","path":"2019/01/16/Emacs学习day1/","date":"01-16","excerpt":"","tags":[{"name":"emacs","slug":"emacs","permalink":"/tags/emacs/"}]},{"title":"一些格式测试","text":"[TOC] 这是一级标题1# 这是一级标题 这是二级标题1## 这是二级标题 列表 元素1 元素2 121. 元素12. 元素2 字体加粗 1**加粗** 斜体 1*斜体* 删除线 1~~删除线~~ 代码1234567#include &lt;iostrea&gt;using namespace std;int main() &#123; cout &lt;&lt; \"Hello World\" &lt;&lt; endl; return 0;&#125; Latex公式行内公式 $ E = mc^2 $ 1$ E = mc^2 $ 整行公式 \\begin{eqnarray} \\nabla\\cdot\\vec{E} &=& \\frac{\\rho}{\\epsilon_0} \\\\ \\nabla\\cdot\\vec{B} &=& 0 \\\\ \\nabla\\times\\vec{E} &=& -\\frac{\\partial B}{\\partial t} \\\\ \\nabla\\times\\vec{B} &=& \\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t} \\right) \\end{eqnarray}12345678$$\\begin&#123;eqnarray&#125;\\nabla\\cdot\\vec&#123;E&#125; &amp;=&amp; \\frac&#123;\\rho&#125;&#123;\\epsilon_0&#125; \\\\\\nabla\\cdot\\vec&#123;B&#125; &amp;=&amp; 0 \\\\\\nabla\\times\\vec&#123;E&#125; &amp;=&amp; -\\frac&#123;\\partial B&#125;&#123;\\partial t&#125; \\\\\\nabla\\times\\vec&#123;B&#125; &amp;=&amp; \\mu_0\\left(\\vec&#123;J&#125;+\\epsilon_0\\frac&#123;\\partial E&#125;&#123;\\partial t&#125; \\right)\\end&#123;eqnarray&#125;$$","path":"2019/01/15/格式测试/","date":"01-15","excerpt":"","tags":[{"name":"测试","slug":"测试","permalink":"/tags/测试/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/01/15/hello-world/","date":"01-15","excerpt":"","tags":[]}]}