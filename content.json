{"pages":[{"title":"404","text":"","path":"404/index.html","date":"01-15","excerpt":""},{"title":"about me","text":"退役ACMer 万年打铁 考研党","path":"about-me/index.html","date":"04-11","excerpt":""},{"title":"关于我","text":"毕业于jxufe，大学期间是软件工程专业。一心想着读CS，目前正在准备考研。","path":"about/index.html","date":"01-15","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-15","excerpt":""}],"posts":[{"title":"Emacs学习day4","text":"SpaceemacsSpaceemacs的安装方法直接从github上clone就好 1git clone git@github.com:syl20bnr/spacemacs.git ~/.emacs.d Spacemacs的一些简单配置配置其它源12345(setq-default configuration-layer--elpa-archives '((\"melpa-cn\" . \"https://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/\") (\"gnu-cn\" . \"https://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/\") (\"org-cn\" . \"https://mirrors.tuna.tsinghua.edu.cn/elpa/org/\")))","path":"2019/01/21/Emacs学习day4/","date":"01-21","excerpt":"","tags":[{"name":"emacs","slug":"emacs","permalink":"/tags/emacs/"}]},{"title":"Emacs学习day3","text":"配置模块化动机之前的配置全部放在init.el文件中，这样各种配置放在一起不便于维护，故把不同的配置拆开放到不同的文件。 配置列表12345678├── init.el└── lisp ├── custom.el ├── init-better-defaults.el ├── init-keybindings.el ├── init-packages.el ├── init-ui.el └── init-org.el 解释1234567init.el 入口custom.el 放customize自动生成的代码init-better-defaults.el 放一些修改默认配置的设置init-keybindings.el 放一些快捷键的绑定init-packages.el 放一些下载的插件的配置init-ui.el 放一些修改显示的配置init-org.el 放一些修改org mode的配置 使用git维护emacs的配置git的基本操作12345git initgit addgit commit -m \"\"git loggit reset --hard 版本号 .gitignoreemacs中的auto-save-list不需要维护，所以在.gitignore中添加 Dired Mode使用 C-x d 就可以进入 Dired Mode，这个模式类似于图形界面系统中的资源管理器。你 可以在其中查看文件和目录的详细信息，对他们进行各种操作，甚至复制粘贴缓冲区中的内 容。下面是一些常用的操作（下面的所有键均需在 Dired Mode 下使用）， + 创建目录 g 刷新目录 C 拷贝 D 删除 R 重命名 d 标记删除 u 取消标记 x 执行所有的标记 删除，拷贝目录时，会询问是否递归删除，拷贝。使用以下配置默认递归 12(setq dired-recursive-deletes 'always)(setq dired-recursive-copies 'always) 每次查找目录时会生成新的buffer，使用以下配置使用唯一缓冲区 123456789(put 'dired-find-alternate-file 'disabled nil);; 主动加载 Dired Mode;; (require 'dired);; (defined-key dired-mode-map (kbd \"RET\") 'dired-find-alternate-file);; 延迟加载(with-eval-after-load 'dired (define-key dired-mode-map (kbd \"RET\") 'dired-find-alternate-file)) 启用 dired-x 可以让每一次进入 Dired 模式时，使用新的快捷键 C-x C-j 就可以进 入当前文件夹的所在的路径。 1(require 'dired-x)","path":"2019/01/20/Emacs学习day3/","date":"01-20","excerpt":"","tags":[{"name":"emacs","slug":"emacs","permalink":"/tags/emacs/"}]},{"title":"codeforces2","text":"A. WinnerThe winner of the card game popular in Berland “Berlogging” is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line “name score”, where name is a player’s name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to m) at the end of the game, than wins the one of them who scored at least m points first. Initially each player has 0 points. It’s guaranteed that at the end of the game at least one player has a positive number of points. Input The first line contains an integer number n (1 ≤ n ≤ 1000), n is the number of rounds played. Then follow n lines, containing the information about the rounds in “name score” format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive. Output Print the name of the winner. Examples input 3 mike 3 andrew 5 mike 2 output andrew input 3 andrew 3 andrew 2 mike 5 output andrew 题意给出n组人名，分数，求最后分数最高的人，如果有多人，就输出最早达到或超过最高分的人。 思路n不大，就记录输入的顺序，先求一遍最后分，得到最大分，最后模拟一遍输入，求到最先得到或超过最高分的人。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const int MAX = 1010;int n;string s[MAX];int cnt[MAX];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; map&lt;string, int&gt; mp; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i] &gt;&gt; cnt[i]; mp[s[i]] += cnt[i]; &#125; int ma = 0; for (auto it = mp.begin(); it != mp.end(); it++) &#123; ma = max(ma, it-&gt;second); &#125; map&lt;string, int&gt; mp2; for (int i = 0; i &lt; n; i++) &#123; mp2[s[i]] += cnt[i]; if (mp[s[i]] == ma &amp;&amp; mp2[s[i]] &gt;= ma) &#123; cout &lt;&lt; s[i] &lt;&lt; endl; break; &#125; &#125; return 0;&#125; B. The least round wayThere is a square matrix n × n, consisting of non-negative integer numbers. You should find such a way on it that starts in the upper left cell of the matrix; each following cell is to the right or down from the current cell; the way ends in the bottom right cell. Moreover, if we multiply together all the numbers along the way, the result should be the least “round”. In other words, it should end in the least possible number of zeros. Input The first line contains an integer number n (2 ≤ n ≤ 1000), n is the size of the matrix. Then follow n lines containing the matrix elements (non-negative integer numbers not exceeding 109). Output In the first line print the least number of trailing zeros. In the second line print the correspondent way itself. Examples input 3 1 2 3 4 5 6 7 8 9 output 0 DDRR 题意从一个矩阵的左上角走到右下角，每次只能选择向下走或者向右走，求一种走法使得路径上的数乘起来末尾的0最少，输出0的个数以及走法。 思路能够产生末尾0的条件就是有因子2和5，或者路径上的数有0，当路径上没有零的时候要使得最后结果末尾0的个数最少只要选择因子2最少的路径和因子5最少的路径中更少的一个即可，当这种路径上因子个数大于等于2的时候则取寻找是否有含有0的路径，有的话直接输出经过0的路径即可。 定义$dp[i][j][0]$为到(i,j)时2的因子个数最少为多少，$dp[i][j][1]$为到(i,j)时5的因子个数最少为多少。 其状态的转移为 \\left\\{\\begin{matrix} dp[i][j][0]=min(dp[i][j-1][0], dp[i-1][j][0])\\\\ dp[i][j][1]=min(dp[i][j-1][1], dp[i][j-1][1]) \\end{matrix}\\right.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int MAX_N = 2010;int n;int get_fac(int num, int f) &#123; if (num == 0) return 1; int cnt = 0; while (num % f == 0) &#123; num /= f; cnt++; &#125; return cnt;&#125;int dp[MAX_N][MAX_N][2];int dir[MAX_N][MAX_N][2];int ans[MAX_N], len = 0;int t, xx, yy;bool has_zero;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;n); has_zero = false; memset(dir, -1, sizeof(dir)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; scanf(\"%d\", &amp;t); if (t == 0) &#123; xx = i; yy = j; has_zero = true; &#125; dp[i][j][0] = get_fac(t, 2); dp[i][j][1] = get_fac(t, 5); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 &amp;&amp; j &gt; 0) &#123; dp[i][j][0] += dp[i][j-1][0]; dp[i][j][1] += dp[i][j-1][1]; dir[i][j][0] = dir[i][j][1] = 0; &#125; if (j == 0 &amp;&amp; i &gt; 0) &#123; dp[i][j][0] += dp[i-1][j][0]; dp[i][j][1] += dp[i-1][j][1]; dir[i][j][0] = dir[i][j][1] = 1; &#125; if (i &gt; 0 &amp;&amp; j &gt; 0) &#123; for (int k = 0; k &lt; 2; k++) &#123; if (dp[i-1][j][k] &lt; dp[i][j-1][k]) &#123; dir[i][j][k] = 1; dp[i][j][k] += dp[i-1][j][k]; &#125; else &#123; dir[i][j][k] = 0; dp[i][j][k] += dp[i][j-1][k]; &#125; &#125; &#125; &#125; &#125; int flag = 0; if (dp[n-1][n-1][0] &lt;= dp[n-1][n-1][1]) &#123; flag = 0; &#125; else &#123; flag = 1; &#125; if (has_zero &amp;&amp; dp[n-1][n-1][flag] &gt; 1) &#123; printf(\"1\\n\"); int p1, p2; p1 = p2 = 0; while (p1 &lt; xx) &#123;p1++; printf(\"D\");&#125; while (p2 &lt; yy) &#123;p2++; printf(\"R\");&#125; while (p1 &lt; n-1) &#123;p1++; printf(\"D\");&#125; while (p2 &lt; n-1) &#123;p2++; printf(\"R\");&#125; printf(\"\\n\"); return 0; &#125; printf(\"%d\\n\", dp[n-1][n-1][flag]); int p1, p2; p1 = p2 = n-1; len = 0; while (dir[p1][p2][flag] != -1) &#123; ans[len++] = dir[p1][p2][flag]; if (dir[p1][p2][flag] == 0) &#123;p2--;&#125; else &#123;p1--;&#125; &#125; for (int i = len-1; i &gt;= 0; i--) &#123; if (ans[i] == 0) printf(\"R\"); else printf(\"D\"); &#125; printf(\"\\n\"); return 0;&#125;","path":"2019/01/19/codeforces2/","date":"01-19","excerpt":"","tags":[{"name":"dp","slug":"dp","permalink":"/tags/dp/"},{"name":"codeforces","slug":"codeforces","permalink":"/tags/codeforces/"},{"name":"模拟","slug":"模拟","permalink":"/tags/模拟/"}]},{"title":"Emacs学习day2","text":"简单的分屏操作 C-x 1 仅保留当前窗口 C-x 2 将当前窗口分到上边 C-x 3 将当前窗口分到右边 更多操作：https://www.gnu.org/software/emacs/manual/html_node/emacs/Split-Window.html Emacs插件源使用MELPA源 一些简单的配置，使用SpaceEmacs Rocks day2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647(when (&gt;= emacs-major-version 24) (require 'package) (package-initialize) (setq package-archives '((\"gnu\" . \"http://elpa.emacs-china.org/gnu/\") (\"melpa\" . \"http://elpa.emacs-china.org/melpa/\"))));; 注意 elpa.emacs-china.org 是 Emacs China 中文社区在国内搭建的一个 ELPA 镜像 ;; cl - Common Lisp Extension (require 'cl) ;; Add Packages (defvar my/packages '( ;; --- Auto-completion --- company ;; --- Better Editor --- hungry-delete swiper counsel smartparens ;; --- Major Mode --- js2-mode ;; --- Minor Mode --- nodejs-repl exec-path-from-shell ;; --- Themes --- monokai-theme ;; solarized-theme ) \"Default packages\") (setq package-selected-packages my/packages) (defun my/packages-installed-p () (loop for pkg in my/packages when (not (package-installed-p pkg)) do (return nil) finally (return t))) (unless (my/packages-installed-p) (message \"%s\" \"Refreshing package database...\") (package-refresh-contents) (dolist (pkg my/packages) (when (not (package-installed-p pkg)) (package-install pkg)))) ;; Find Executable Path on OS X (when (memq window-system '(mac ns)) (exec-path-from-shell-initialize)) 一些其它的配置 12345678;; 高亮当前行(global-hl-line-mode 1);; 默认全屏(setq initial-frame-alist (quote ((fullscreen . maximized))));; 匹配括号(add-hook 'emacs-lisp-mode-hook 'show-paren-mode) auto-mode-list匹配Major Mode使用正则表达式匹配Major Mode 123456789(setq auto-mode-alist (append ;; File name (within directory) starts with a dot. '((\"/\\\\.[^/]*\\\\'\" . fundamental-mode) ;; File name has no dot. (\"/[^\\\\./]*\\\\'\" . fundamental-mode) ;; File name ends in ‘.C’. (\"\\\\.C\\\\'\" . c++-mode)) auto-mode-alist))","path":"2019/01/18/Emacs学习day2/","date":"01-18","excerpt":"","tags":[{"name":"emacs","slug":"emacs","permalink":"/tags/emacs/"}]},{"title":"codeforces1","text":"A. Theatre SquareTheatre Square in the capital city of Berland has a rectangular shape with the size n × m meters. On the occasion of the city’s anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size a × a. What is the least number of flagstones needed to pave the Square? It’s allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It’s not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square. Input The input contains three positive integer numbers in the first line: n, m and a (1 ≤ n, m, a ≤ 109). Output Write the needed number of flagstones. Examples input 6 6 4 output 4 题意 n × m 的剧院，要用 a ×a 的石板铺满，石板要和剧院的边界平行，石板不能切割，但铺盖的范围可以超过剧院的边界。求最少用多少块石板。 思路从剧院的左上角开始铺，直到刚好铺满一行或刚好超过，可知每行铺$ \\left \\lceil \\frac{m}{a} \\right \\rceil $，同理每列铺$\\left \\lceil \\frac{n}{a} \\right \\rceil$。 代码12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;ll n, m, a;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%lld %lld %lld\", &amp;n, &amp;m, &amp;a); printf(\"%lld\\n\", (ll)ceil(1.0 * n / a) * (ll)ceil(1.0 * m / a)); return 0;&#125; B. SpreadsheetsIn the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc. The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example. Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system. Input The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 . Output Write n lines, each line should contain a cell coordinates in the other numeration system. Examples input 2 R23C55 BC23 output BC23 R23C55 题意对输入的格式进行转换，将(R, C)的形式转换成A-Z的列表示+数字的行表示，将A-Z的列表示+数字的行表示转换成(R,C)的形式 思路纯模拟题，先扫描输入的字符串，看有多少个数字部分，1，2分别对应两种格式，创造数字字符串转换成整型的函数，A-Z的字符串转换成整型的函数，整型转换成A-Z的字符串函数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int MAX_N = 1000010;char s[MAX_N];int len, n, num, p;int str2num(char ss[], int &amp;p) &#123; int ans = 0; while (ss[p] != '\\0' &amp;&amp; isdigit(ss[p])) &#123; ans *= 10; ans += ss[p] - '0'; p++; &#125; return ans;&#125;void num2ABC(int dig) &#123; int tmp[10000]; int tlen = 0; while (dig) &#123; int t = dig % 26; if (t == 0) &#123; tmp[tlen++] = 26; dig = dig / 26 - 1; &#125; else &#123; tmp[tlen++] = t; dig = dig / 26; &#125; &#125; for (int i = tlen-1; i &gt;= 0; i--) &#123; printf(\"%c\", 'A'+tmp[i]-1); &#125;&#125;int ABC2num(char ss[], int &amp;p) &#123; int ans = 0; while (ss[p] != '\\0' &amp;&amp; isalpha(ss[p])) &#123; ans *= 26; ans += ss[p] - 'A' + 1; p++; &#125; return ans;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;n); while (n--) &#123; scanf(\"%s\", s); len = strlen(s); num = 0; p = 0; for (int i = 1; i &lt; len; i++) &#123; if (isalpha(s[i-1]) &amp;&amp; isdigit(s[i])) &#123; num++; &#125; &#125; if (num == 1) &#123; p = 0; int b = ABC2num(s, p); int a = str2num(s, p); printf(\"R%dC%d\\n\", a, b); &#125; else if (num == 2) &#123; p = 1; int a = str2num(s, p); p++; int b = str2num(s, p); num2ABC(b); printf(\"%d\\n\", a); &#125; &#125; return 0;&#125; C. Ancient Berland CircusNowadays all circuses in Berland have a round arena with diameter 13 meters, but in the past things were different. In Ancient Berland arenas in circuses were shaped as a regular (equiangular) polygon, the size and the number of angles could vary from one circus to another. In each corner of the arena there was a special pillar, and the rope strung between the pillars marked the arena edges. Recently the scientists from Berland have discovered the remains of the ancient circus arena. They found only three pillars, the others were destroyed by the time. You are given the coordinates of these three pillars. Find out what is the smallest area that the arena could have. Input The input file consists of three lines, each of them contains a pair of numbers –– coordinates of the pillar. Any coordinate doesn’t exceed 1000 by absolute value, and is given with at most six digits after decimal point. Output Output the smallest possible area of the ancient arena. This number should be accurate to at least 6 digits after the decimal point. It’s guaranteed that the number of angles in the optimal polygon is not larger than 100. Examples input 0.000000 0.000000 1.000000 1.000000 0.000000 1.000000 output 1.00000000 题意给出正多边形的三个顶点，求此多边形的最小面积 思路3个顶点可以确定此多边形的中心就是这个三角形的外心，易知正n边形中n越小则面积越小，求三角形外心以及三个顶点中的两个组成圆心角的最大公约数，再用2PI除以其最大公约数就可以得到n 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const double EPS = 1e-4;const double PI = acos(-1.0);struct Point &#123; double x, y; void read() &#123; scanf(\"%lf %lf\", &amp;x, &amp;y); &#125;&#125;;double dis(Point p1, Point p2) &#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y));&#125;double gcd(double x, double y) &#123; return y &gt; EPS ? gcd(y, x-floor(x/y)*y) : x;&#125;double getTheta(double a, double b, double c) &#123; return acos((a * a + b * b - c * c) / (2 * a * b));&#125;Point p1, p2, p3;double d1, d2, d3, p, s, r, theta1, theta2, theta3, n, theta, ans;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); p1.read(); p2.read(); p3.read(); d1 = dis(p1, p2); d2 = dis(p1, p3); d3 = dis(p2, p3); p = (d1 + d2 + d3) / 2.0; s = sqrt(p * (p-d1) * (p-d2) * (p - d3)); r = (d1 * d2 * d3) / (4.0 * s); theta1 = getTheta(r, r, d3); theta2 = getTheta(r, r, d2); theta3 = 2 * PI - theta1 - theta2; theta = (gcd(theta1, gcd(theta2, theta3))); n = PI / theta; ans = n * r * r * sin(theta); printf(\"%.6lf\\n\", ans); return 0;&#125;","path":"2019/01/16/codeforces1/","date":"01-16","excerpt":"","tags":[{"name":"计算几何","slug":"计算几何","permalink":"/tags/计算几何/"},{"name":"codeforces","slug":"codeforces","permalink":"/tags/codeforces/"},{"name":"模拟","slug":"模拟","permalink":"/tags/模拟/"},{"name":"数学","slug":"数学","permalink":"/tags/数学/"}]},{"title":"Emacs学习day1","text":"学习emacs tutorialemacs tutorial中有一些常用的emacs操作，学习emacs中的一些函数操作之前先把一些基本的光标操作过一遍。 打开emacs tutorial的方式 直接点击emacs tutorial 输入C-h t 基本操作文件（buffer）操作 C-x C-c 关闭emacs（不保存） C-x C-f 打开文件 C-x C-s 保存 光标操作 C-f 为前移一个字符， f 代表 forward。 C-b 为后移一个字符， b 代表 backward。 C-p 为上移至前一行， p 代表 previous。 C-n 为上移至下一行， n 代表 next。 C-a 为移至行首， a 代表 ahead。 C-e 为移至行尾， e 代表 end。 帮助快捷键 C-h k 寻找快捷键的帮助信息 C-h v 寻找变量的帮助信息 C-h f 寻找函数的帮助信息 Elisp学习链接：https://learnxinyminutes.com/docs/elisp/ 编辑器配置配置文件emacs的配置文件默认路径是~/.emacs.d/init.el 基本配置配置直接用了Spacemacs Rocks中day1的配置，链接：http://book.emacs-china.org/ 1234567891011121314151617181920212223242526272829;; 关闭工具栏，tool-bar-mode 即为一个 Minor Mode(tool-bar-mode -1);; 关闭文件滑动控件(scroll-bar-mode -1);; 显示行号(global-linum-mode 1);; 更改光标的样式（不能生效，解决方案见第二集）(setq cursor-type 'bar);; 关闭启动帮助画面(setq inhibit-splash-screen 1);; 关闭缩进 (第二天中被去除);; (electric-indent-mode -1);; 更改显示字体大小 16pt;; http://stackoverflow.com/questions/294664/how-to-set-the-font-size-in-emacs(set-face-attribute 'default nil :height 160);; 快速打开配置文件(defun open-init-file() (interactive) (find-file \"~/.emacs.d/init.el\"));; 这一行代码，将函数 open-init-file 绑定到 &lt;f2&gt; 键上(global-set-key (kbd \"&lt;f2&gt;\") 'open-init-file) mode的区别emacs中有两种mode major mode minor mode 其中major mode一个文件只能有一个，minor mode能有[0, n]个","path":"2019/01/16/Emacs学习day1/","date":"01-16","excerpt":"","tags":[{"name":"emacs","slug":"emacs","permalink":"/tags/emacs/"}]},{"title":"一些格式测试","text":"[TOC] 这是一级标题1# 这是一级标题 这是二级标题1## 这是二级标题 列表 元素1 元素2 121. 元素12. 元素2 字体加粗 1**加粗** 斜体 1*斜体* 删除线 1~~删除线~~ 代码1234567#include &lt;iostrea&gt;using namespace std;int main() &#123; cout &lt;&lt; \"Hello World\" &lt;&lt; endl; return 0;&#125; Latex公式行内公式 $ E = mc^2 ​$ 1$ E = mc^2 $ 整行公式 \\begin{eqnarray} \\nabla\\cdot\\vec{E} &=& \\frac{\\rho}{\\epsilon_0} \\\\ \\nabla\\cdot\\vec{B} &=& 0 \\\\ \\nabla\\times\\vec{E} &=& -\\frac{\\partial B}{\\partial t} \\\\ \\nabla\\times\\vec{B} &=& \\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t} \\right) \\end{eqnarray}12345678$$\\begin&#123;eqnarray&#125;\\nabla\\cdot\\vec&#123;E&#125; &amp;=&amp; \\frac&#123;\\rho&#125;&#123;\\epsilon_0&#125; \\\\\\nabla\\cdot\\vec&#123;B&#125; &amp;=&amp; 0 \\\\\\nabla\\times\\vec&#123;E&#125; &amp;=&amp; -\\frac&#123;\\partial B&#125;&#123;\\partial t&#125; \\\\\\nabla\\times\\vec&#123;B&#125; &amp;=&amp; \\mu_0\\left(\\vec&#123;J&#125;+\\epsilon_0\\frac&#123;\\partial E&#125;&#123;\\partial t&#125; \\right)\\end&#123;eqnarray&#125;$$","path":"2019/01/15/格式测试/","date":"01-15","excerpt":"","tags":[{"name":"测试","slug":"测试","permalink":"/tags/测试/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/01/15/hello-world/","date":"01-15","excerpt":"","tags":[]},{"title":"SPOJ-DQUERY","text":"题意给一个长度为n的序列，q个询问，每次询问区间[l,r]中不同的数有多少个。 输入第一行n 第二行n个数 第三行q q行询问 输出数量 输入样例51 1 2 1 331 52 43 5 输出样例323 思路预处理每个数上一次出现的位置。用主席树维护区间内每个位置出现的次数。如果一个数不是第一次出现那么上次的位置一定在[l,r]中，所以我们能在[latex]O(log(n)) [/latex]的时间内求出不是第一出现的数的个数，用区间长度减去就能得到不同数的个数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;template&lt;class T, size_t size&gt;struct MemoryPool &#123; T buf[size], *tail, *st[size]; int top; MemoryPool() : top(0), tail(buf) &#123;&#125; inline T *alloc() &#123;return top ? st[--top] : tail++;&#125; inline void recycle(T *x) &#123;st[top++] = x;&#125; inline void clear() &#123; tail = buf; top = 0; &#125;&#125;;const int MAX_N = 1000100;struct FunSegTree &#123; struct Node &#123; int l, r; Node *lc, *rc; int cnt; static inline Node *newNode(MemoryPool&lt;Node, MAX_N&gt; &amp;pool, const int l, const int r, Node *lc = NULL, Node *rc = NULL) &#123; Node *tmp = pool.alloc(); tmp-&gt;l = l; tmp-&gt;r = r; tmp-&gt;lc = lc; tmp-&gt;rc = rc; tmp-&gt;cnt = (lc ? lc-&gt;cnt : 0) + (rc ? rc-&gt;cnt : 0); return tmp; &#125; static inline Node *newNode(MemoryPool&lt;Node, MAX_N&gt; &amp;pool, const int l, const int r, const int cnt) &#123; Node *tmp = pool.alloc(); tmp-&gt;l = l; tmp-&gt;r = r; tmp-&gt;cnt = cnt; tmp-&gt;lc = NULL; tmp-&gt;rc = NULL; return tmp; &#125; inline void pushDown(MemoryPool&lt;Node, MAX_N&gt; &amp;pool) &#123; if (lc &amp;&amp; rc) return ; int m = (l + r) &gt;&gt; 1; if (!lc) lc = newNode(pool, l, m); if (!rc) rc = newNode(pool, m+1, r); &#125; inline Node *insert(MemoryPool&lt;Node, MAX_N&gt; &amp;pool, const int num) &#123; if (num &lt; l || num &gt; r) return this; else if (num == l &amp;&amp; num == r) return newNode(pool, l, r, this-&gt;cnt+1); else &#123; int m = (l + r) &gt;&gt; 1; pushDown(pool); if (num &lt;= m) return newNode(pool, l, r, lc-&gt;insert(pool, num), rc); else return newNode(pool, l, r, lc, rc-&gt;insert(pool, num)); &#125; &#125; inline int query(MemoryPool&lt;Node, MAX_N&gt; &amp;pool, int L, int R) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return cnt; &#125; pushDown(pool); int m = (l + r) &gt;&gt; 1; int res = 0; if (L &lt;= m) res += (lc ? lc-&gt;query(pool, L, R) : 0); if (m &lt; R) res += (rc ? rc-&gt;query(pool, L, R) : 0); return res; &#125; inline int rank() const &#123; return (lc ? lc-&gt;cnt : 0); &#125; &#125;*root[MAX_N+1]; MemoryPool&lt;Node, MAX_N&gt; pool; int n; inline void build(const int *a, const int n) &#123; this-&gt;n = n; root[0] = Node::newNode(pool, 0, n); for (int i = 1; i &lt;= n; i++) &#123; root[i] = root[i-1]-&gt;insert(pool, a[i-1]); &#125; &#125; inline int query(const int l, const int r) &#123; Node *L = root[l-1], *R = root[r]; return (R-&gt;query(pool, l, r) - L-&gt;query(pool, l, r)); &#125; void clear() &#123; pool.clear(); &#125;&#125;tree;int T;int n, q;int a[MAX_N];int pre[1000010];int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); memset(pre, 0, sizeof(pre)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); int t = a[i]; a[i] = pre[t]; pre[t] = i; &#125; scanf(\"%d\", &amp;q); tree.build(a+1, n); int l, r; for (int i = 0; i &lt; q; i++) &#123; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%d\\n\", (r-l+1)-tree.query(l, r)); &#125; return 0;&#125;","path":"2018/06/03/spoj-dquery/","date":"06-03","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"可持久化线段树","slug":"可持久化线段树","permalink":"/tags/可持久化线段树/"},{"name":"SPOJ","slug":"SPOJ","permalink":"/tags/SPOJ/"}]},{"title":"HDU6278Just h-index","text":"题意给一个长度为n的序列，q个询问，每次询问[l,r]区间内的h-index，h-index指的是最大的h，在[l,r]这个区间内满足，有h个数的值大于等于h。 输入第一行n，q，n表示n个数，q表示q次询问 第二行n个数 剩下q行每行两个数l，r表示[l,r]这个区间。 输出每个询问输出一行。 输入样例5 31 5 3 2 11 32 41 55 11 2 3 4 51 5 输出样例2223 思路主席树求静态区间第k大，二分答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;template&lt;class T, size_t size&gt;struct MemoryPool &#123; T buf[size], *tail, *st[size]; int top; MemoryPool() : top(0), tail(buf) &#123;&#125; inline T *alloc() &#123;return top ? st[--top] : tail++;&#125; inline void recycle(T *x) &#123;st[top++] = x;&#125; inline void clear() &#123; tail = buf; top = 0; &#125;&#125;;const int MAX_N = 4000100;struct FunSegTree &#123; struct Node &#123; int l, r; Node *lc, *rc; int cnt; static inline Node *newNode(MemoryPool&lt;Node, MAX_N&gt; &amp;pool, const int l, const int r, Node *lc = NULL, Node *rc = NULL) &#123; Node *tmp = pool.alloc(); tmp-&gt;l = l; tmp-&gt;r = r; tmp-&gt;lc = lc; tmp-&gt;rc = rc; tmp-&gt;cnt = (lc ? lc-&gt;cnt : 0) + (rc ? rc-&gt;cnt : 0); return tmp; &#125; static inline Node *newNode(MemoryPool&lt;Node, MAX_N&gt; &amp;pool, const int l, const int r, const int cnt) &#123; Node *tmp = pool.alloc(); tmp-&gt;l = l; tmp-&gt;r = r; tmp-&gt;cnt = cnt; tmp-&gt;lc = NULL; tmp-&gt;rc = NULL; return tmp; &#125; inline void pushDown(MemoryPool&lt;Node, MAX_N&gt; &amp;pool) &#123; if (lc &amp;&amp; rc) return ; int m = (l + r) &gt;&gt; 1; if (!lc) lc = newNode(pool, l, m); if (!rc) rc = newNode(pool, m+1, r); &#125; inline Node *insert(MemoryPool&lt;Node, MAX_N&gt; &amp;pool, const int num) &#123; if (num &lt; l || num &gt; r) return this; else if (num == l &amp;&amp; num == r) return newNode(pool, l, r, this-&gt;cnt+1); else &#123; int m = (l + r) &gt;&gt; 1; pushDown(pool); if (num &lt;= m) return newNode(pool, l, r, lc-&gt;insert(pool, num), rc); else return newNode(pool, l, r, lc, rc-&gt;insert(pool, num)); &#125; &#125; inline int rank() const &#123; return (lc ? lc-&gt;cnt : 0); &#125; &#125;*root[MAX_N+1]; MemoryPool&lt;Node, MAX_N&gt; pool; int n; inline void build(const int *a, const int n) &#123; this-&gt;n = n; root[0] = Node::newNode(pool, 0, n-1); for (int i = 1; i &lt;= n; i++) &#123; root[i] = root[i-1]-&gt;insert(pool, a[i-1]); &#125; &#125; inline int query(const int l, const int r, int k) &#123; Node *L = root[l-1], *R = root[r]; k = (r - l + 2) - k; int mi = 0, ma = n-1; while (mi != ma) &#123; L-&gt;pushDown(pool); R-&gt;pushDown(pool); int m = (mi + ma) &gt;&gt; 1, t = R-&gt;rank()-L-&gt;rank(); if (k &lt;= t) L = L-&gt;lc, R = R-&gt;lc, ma = m; else k -= t, L = L-&gt;rc, R = R-&gt;rc, mi = m + 1; &#125; return mi; &#125; void clear() &#123; pool.clear(); &#125;&#125;tree;int n, q;int a[MAX_N], b[MAX_N];int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d %d\", &amp;n, &amp;q)) &#123; tree.clear(); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; memcpy(b, a, sizeof(a)); sort(b, b+n); int *end = unique(b, b+n); for (int i = 0; i &lt; n; i++) &#123; a[i] = lower_bound(b, end, a[i])-b; &#125; tree.build(a, n); int l, r; for (int i = 0; i &lt; q; i++) &#123; scanf(\"%d%d\", &amp;l, &amp;r); int lo = 1, hi = (r-l+1)+1; while (lo &lt; hi) &#123; int m = (lo + hi) &gt;&gt; 1; int t = tree.query(l, r, m); if (b[t] &gt;= m) &#123; lo = m+1; &#125; else &#123; hi = m; &#125; &#125; printf(\"%d\\n\", --lo); &#125; &#125; return 0;&#125;","path":"2018/06/03/hdu6278just-h-index/","date":"06-03","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"二分","slug":"二分","permalink":"/tags/二分/"},{"name":"HDU","slug":"HDU","permalink":"/tags/HDU/"},{"name":"可持久化线段树","slug":"可持久化线段树","permalink":"/tags/可持久化线段树/"}]},{"title":"HDU1402A * B Problem Plus","text":"描述计算A*B 输入输入数的长度不超过5000 输出结果 输入样例1210002 输出样例22000 思路大数应该过不了，fft模版可过。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;struct Complex&#123; double r, i; Complex() &#123;&#125; Complex(double r, double i) : r(r), i(i) &#123;&#125; inline void real(const double &amp;x) &#123; r = x; &#125; inline double real() &#123; return r; &#125; inline Complex operator + (const Complex &amp;rhs) const &#123; return Complex(r + rhs.r, i + rhs.i); &#125; inline Complex operator - (const Complex &amp;rhs) const &#123; return Complex(r - rhs.r, i - rhs.i); &#125; inline Complex operator * (const Complex &amp;rhs) const &#123; return Complex(r * rhs.r - i * rhs.i, r * rhs.i + i * rhs.r); &#125; inline void operator /= (const double &amp;x) &#123; r /= x, i /= x; &#125; inline void operator *= (const Complex &amp;rhs) &#123; *this = Complex(r * rhs.r - i * rhs.i, r * rhs.i + i * rhs.r); &#125; inline void operator += (const Complex &amp;rhs) &#123; r += rhs.r, i += rhs.i; &#125; inline Complex conj() &#123; return Complex(r, -i); &#125;&#125;;const int MAX_N = 140000;const double PI = acos(-1);struct FFT&#123; Complex omega[MAX_N], omegaInverse[MAX_N]; void init(const int &amp;n) &#123; for (int i = 0; i &lt; n; i++) &#123; omega[i] = Complex(cos(2 * PI / n * i), sin (2 * PI / n * i)); omegaInverse[i] = omega[i].conj(); &#125; &#125; void transform(Complex *a, const int &amp;n, const Complex *omega) &#123; for (int i = 0, j = 0; i &lt; n; i++) &#123; if (i &gt; j) swap(a[i], a[j]); for (int l = n &gt;&gt; 1; (j ^= l) &lt; l; l &gt;&gt;= 1); &#125; for (int l = 2; l &lt;= n; l &lt;&lt;= 1) &#123; int m = l / 2; for (Complex *p = a; p != a + n; p += l) &#123; for (int i = 0; i &lt; m; i++) &#123; Complex t = omega [n / l * i] * p [m + i]; p[m + i] = p[i] - t; p[i] += t; &#125; &#125; &#125; &#125; void dft(Complex *a, const int &amp;n) &#123; transform(a, n, omega); &#125; void idft(Complex *a, const int &amp;n) &#123; transform(a, n, omegaInverse); for(int i = 0; i &lt; n; i++) a[i] /= n; &#125;&#125;fft;char numA[50010], numB[50010];Complex a[MAX_N], b[MAX_N];int ans[MAX_N];int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%s %s\", numA, numB)) &#123; int lenA = strlen(numA); int sa = 0; while ((1 &lt;&lt; sa) &lt; lenA) sa++; int lenB = strlen(numB); int sb = 0; while ((1 &lt;&lt; sb) &lt; lenB) sb++; int len = (1 &lt;&lt; (max(sa, sb)+1)); fft.init(len); for (int i = 0; i &lt; len; i++) &#123; if (i &lt; lenA) a[i] = Complex(numA[lenA-i-1] - '0', 0); else a[i] = Complex(0, 0); if (i &lt; lenB) b[i] = Complex(numB[lenB-i-1] - '0', 0); else b[i] = Complex(0, 0); &#125; fft.dft(a, len); fft.dft(b, len); for(int i = 0; i &lt; len; i++) a[i] = a[i]*b[i]; fft.idft(a, len); for (int i = 0; i &lt; len; i++) &#123; ans[i] = (int)(a[i].real() + 0.5); &#125; for (int i = 0; i &lt; len - 1; i++) &#123; ans[i + 1] += ans[i] / 10; ans[i] %= 10; &#125; bool flag = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; if (ans[i]) printf(\"%d\", ans[i]), flag = 1; else if (flag || i == 0) printf(\"0\"); &#125; printf(\"\\n\"); &#125; return 0;&#125;","path":"2018/05/27/hdu1402a-b-problem-plus/","date":"05-27","excerpt":"","tags":[{"name":"高精度","slug":"高精度","permalink":"/tags/高精度/"},{"name":"数学","slug":"数学","permalink":"/tags/数学/"},{"name":"fft","slug":"fft","permalink":"/tags/fft/"},{"name":"HDU","slug":"HDU","permalink":"/tags/HDU/"}]},{"title":"BZOJ2763[JLOI2011]飞行路线","text":"描述Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在n个城市设有业务，设这些城市分别标记为0到n-1，一共有m种航线，每种航线连接两个城市，并且航线有一定的价格。Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多k种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？ 输入数据的第一行有三个整数，n,m,k，分别表示城市数，航线数和免费乘坐次数。 第二行有两个整数，s,t，分别表示他们出行的起点城市编号和终点城市编号。(0&lt;=s,t&lt;n) 接下来有m行，每行三个整数，a,b,c，表示存在一种航线，能从城市a到达城市b，或从城市b到达城市a，价格为c。(0&lt;=a,b&lt;n,a与b不相等，0&lt;=c&lt;=1000) 输出只有一行，包含一个整数，为最少花费。 输入样例5 6 10 40 1 51 2 52 3 53 4 52 3 30 2 100 输出样例8 思路没有免费次数那就是一个最短路的模板题，加了个免费次数可以把这个图复制k层，可以从第i层到第i+1层，第i层表示使用了i此免费次数，然后直接spfa即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt; using namespace std; const int MAX_N = 20010;const int MAX_M = 100010;const int INF = 0x3f3f3f3f; int n, m, k; struct Data &#123; int to, nxt, c;&#125;e[MAX_M]; int head[MAX_N], cnt = 1;int src, sink; void ins(int u, int v, int c) &#123; cnt++; e[cnt].to = v; e[cnt].c = c; e[cnt].nxt = head[u]; head[u] = cnt;&#125; int dist[MAX_N][12];int inQue[MAX_N][12];struct Node &#123; int v, f; Node() &#123;&#125; Node(int _v, int _f) : v(_v), f(_f) &#123;&#125;&#125;;queue&lt;Node&gt; que; void spfa() &#123; while (!que.empty()) que.pop(); memset(inQue, 0, sizeof(inQue)); memset(dist, 0x3f, sizeof(dist)); for (int i = 0; i &lt;= k; i++) &#123; que.push(Node(src, i)); inQue[src][i] = true; dist[src][i] = 0; &#125; while (!que.empty()) &#123; Node now = que.front(); que.pop(); for (int i = head[now.v]; i; i = e[i].nxt) &#123; if (dist[e[i].to][now.f] &gt; dist[now.v][now.f] + e[i].c) &#123; dist[e[i].to][now.f] = dist[now.v][now.f] + e[i].c; if (!inQue[e[i].to][now.f]) &#123; inQue[e[i].to][now.f] = true; que.push(Node(e[i].to, now.f)); &#125; &#125; if (now.f &lt; k) &#123; if (dist[e[i].to][now.f+1] &gt; dist[now.v][now.f]) &#123; dist[e[i].to][now.f+1] = dist[now.v][now.f]; if (!inQue[e[i].to][now.f+1]) &#123; inQue[e[i].to][now.f+1] = true; que.push(Node(e[i].to, now.f+1)); &#125; &#125; &#125; &#125; inQue[now.v][now.f] = false; &#125;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); scanf(\"%d%d\", &amp;src, &amp;sink); for (int i = 0; i &lt; m; i++) &#123; int u, v, c; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;c); ins(u, v, c); ins(v, u, c); &#125; spfa(); int ans = INF; for (int i = 0 ; i &lt;= k; i++) &#123; ans = min(ans, dist[sink][i]); &#125; printf(\"%d\\n\", ans); return 0;&#125;","path":"2018/05/16/bzoj2763jloi2011-e9-a3-9e-e8-a1-8c-e8-b7-af-e7-ba-bf/","date":"05-16","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"spfa","slug":"spfa","permalink":"/tags/spfa/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"}]},{"title":"BZOJ1221[HNOI2001] 软件开发","text":"描述某软件公司正在规划一项n天的软件开发计划，根据开发计划第i天需要ni个软件开发人员，为了提高软件开发人员的效率，公司给软件人员提供了很多的服务，其中一项服务就是要为每个开发人员每天提供一块消毒毛巾，这种消毒毛巾使用一天后必须再做消毒处理后才能使用。消毒方式有两种，A种方式的消毒需要a天时间，B种方式的消毒需要b天（b&gt;a），A种消毒方式的费用为每块毛巾fA, B种消毒方式的费用为每块毛巾fB，而买一块新毛巾的费用为f（新毛巾是已消毒的，当天可以使用）；而且f&gt;fA&gt;fB。公司经理正在规划在这n天中，每天买多少块新毛巾、每天送多少块毛巾进行A种消毒和每天送多少块毛巾进行B种消毒。当然，公司经理希望费用最低。你的任务就是：为该软件公司计划每天买多少块毛巾、每天多少块毛巾进行A种消毒和多少毛巾进行B种消毒，使公司在这项n天的软件开发中，提供毛巾服务的总费用最低。 输入第1行为n,a,b,f,fA,fB. 第2行为n1，n2，……，nn. （注：1≤f,fA,fB≤60，1≤n≤1000） 输出最少费用 输入样例4 1 2 3 2 18 2 1 6 输出样例38 思路把第i天拆成两个点xi，yi。源点连向xi容量为INF，费用为f。源点连向yi容量为need[i]费用为0，表示第i天能产生need[i]件毛巾可以洗。yi连向x(i+a+1)容量为INF费用为fa，yi连向x(i+b+1)容量为INF费用为fb。yi连向y(i+1)容量为INF费用为0，表示毛巾可以不一天洗完。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt; using namespace std; const int MAX_N = 2010;const int INF = 0x3f3f3f3f; struct Edge &#123; Edge() &#123;&#125; Edge(int a, int b, int c, int d) &#123; v = a; f = b; w = c; nxt = d; &#125; int v, f, w, nxt;&#125;e[MAX_N * 10]; int g[MAX_N], nume, src, sink; void addEdge(int u, int v, int c, int w) &#123; e[++nume] = Edge(v, c, w, g[u]); g[u] = nume; e[++nume] = Edge(u, 0, -w, g[v]); g[v] = nume;&#125; queue&lt;int&gt; que;bool inQue[MAX_N];int dist[MAX_N];int pre[MAX_N], pree[MAX_N]; bool findPath() &#123; while (!que.empty()) que.pop(); que.push(src); memset(dist, 0x3f, sizeof(dist)); memset(inQue, 0, sizeof(inQue)); dist[src] =0; inQue[src] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = g[u]; i; i = e[i].nxt) &#123; if (e[i].f &gt; 0 &amp;&amp; dist[u] + e[i].w &lt; dist[e[i].v]) &#123; dist[e[i].v] = dist[u] + e[i].w; pre[e[i].v] = u; pree[e[i].v] = i; if (!inQue[e[i].v]) &#123; inQue[e[i].v] = true; que.push(e[i].v); &#125; &#125; &#125; inQue[u] = false; &#125; if (dist[sink] &lt; INF) return true; else return false;&#125; int augment() &#123; int u = sink; int delta = INF; while (u != src) &#123; if (e[pree[u]].f &lt; delta) delta = e[pree[u]].f; u = pre[u]; &#125; u = sink; while (u != src) &#123; e[pree[u]].f -= delta; e[pree[u] ^ 1].f += delta; u = pre[u]; &#125; return dist[sink] * delta;&#125; int mincostflow() &#123; int cur = 0; while (findPath()) &#123; cur += augment(); &#125; return cur;&#125; int n, a, b, f, fa, fb;int need[MAX_N]; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d%d%d%d%d\", &amp;n, &amp;a, &amp;b, &amp;f, &amp;fa, &amp;fb); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;need[i]); &#125; memset(g, 0, sizeof(g)); nume = 1; src = 0; sink = MAX_N - 1; for (int i = 1; i &lt;= n; i++) &#123; addEdge(src, i, INF, f); addEdge(src, i + n, need[i], 0); addEdge(i, sink, need[i], 0); if (i + a + 1 &lt;= n) addEdge(i + n, i + a + 1, INF, fa); if (i + b + 1 &lt;= n) addEdge(i + n, i + b + 1, INF, fb); if (i + 1 &lt;= n) addEdge(i + n, i + n + 1, INF, 0); &#125; printf(\"%d\\n\", mincostflow()); return 0;&#125;","path":"2018/05/15/bzoj1221hnoi2001-e8-bd-af-e4-bb-b6-e5-bc-80-e5-8f-91/","date":"05-15","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"最小费用流","slug":"最小费用流","permalink":"/tags/最小费用流/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"}]},{"title":"BZOJ2424[HAOI2010]订货","text":"描述某公司估计市场在第i个月对某产品的需求量为Ui，已知在第i月该产品的订货单价为di，上个月月底未销完的单位产品要付存贮费用m，假定第一月月初的库存量为零，第n月月底的库存量也为零，问如何安排这n个月订购计划，才能使成本最低？每月月初订购，订购后产品立即到货，进库并供应市场，于当月被售掉则不必付存贮费。假设仓库容量为S。 输入第1行：n, m, S (0&lt;=n&lt;=50, 0&lt;=m&lt;=10, 0&lt;=S&lt;=10000) 第2行：U1 , U2 , … , Ui , … , Un (0&lt;=Ui&lt;=10000) 第3行：d1 , d2 , …, di , … , dn (0&lt;=di&lt;=100) 输出只有**1**行，一个整数，代表最低成本 输入样例3 1 10002 4 81 2 4 输出样例34 思路源点和第i天相连容量为INF费用为d[I]，第i天和汇点相连容量为u[i]费用为0，第i天和第i+1天相连容量为s费用为m。求最小费用流即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt; using namespace std; const int MAX_N = 100;const int INF = 0x3f3f3f3f; struct Edge &#123; Edge() &#123;&#125; Edge(int a, int b, int c, int d) &#123; v = a; f = b; w = c; nxt = d; &#125; int v, f, w, nxt;&#125;e[MAX_N &lt;&lt; 2]; int g[MAX_N];int nume;int src, sink; void addEdge(int u, int v, int c, int w) &#123; e[++nume] = Edge(v, c, w, g[u]); g[u] = nume; e[++nume] = Edge(u, 0, -w, g[v]); g[v] = nume;&#125; queue&lt;int&gt; que;bool inQue[MAX_N];int dist[MAX_N];int pre[MAX_N], pree[MAX_N]; bool findPath() &#123; while (!que.empty()) que.pop(); que.push(src); fill(dist, dist+MAX_N, INF); memset(inQue, 0, sizeof(inQue)); dist[src] = 0; inQue[src] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = g[u]; i; i = e[i].nxt) &#123; if (e[i].f &gt; 0 &amp;&amp; dist[u] + e[i].w &lt; dist[e[i].v]) &#123; dist[e[i].v] = dist[u] + e[i].w; pre[e[i].v] = u; pree[e[i].v] = i; if (!inQue[e[i].v]) &#123; inQue[e[i].v] = true; que.push(e[i].v); &#125; &#125; &#125; inQue[u] = false; &#125; if (dist[sink] &lt; INF) return true; else return false;&#125; int augment() &#123; int u = sink; int delta = INF; while (u != src) &#123; if (e[pree[u]].f &lt; delta) delta = e[pree[u]].f; u = pre[u]; &#125; u = sink; while (u != src) &#123; e[pree[u]].f -= delta; e[pree[u]^1].f += delta; u = pre[u]; &#125; return dist[sink] * delta;&#125; int mincostflow() &#123; int cur = 0; while (findPath()) &#123; cur += augment(); &#125; return cur;&#125; int n, m, s;int u[MAX_N];int d[MAX_N]; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;u[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;d[i]); &#125; src = 0; sink = n+1; memset(g, 0, sizeof(g)); nume = 1; for (int i = 1; i &lt;= n; i++) &#123; addEdge(src, i, INF, d[i]); addEdge(i, sink, u[i], 0); &#125; for (int i = 1; i &lt; n; i++) &#123; addEdge(i, i+1, s, m); &#125; printf(\"%d\\n\", mincostflow()); return 0;&#125;","path":"2018/05/15/bzoj2424haoi2010-e8-ae-a2-e8-b4-a7/","date":"05-15","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"最小费用流","slug":"最小费用流","permalink":"/tags/最小费用流/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"}]},{"title":"BZOJ3171[Tjoi2013]循环格","text":"描述一个循环格就是一个矩阵，其中所有元素为箭头，指向相邻四个格子。每个元素有一个坐标（行，列），其中左上角元素坐标为（0,0）。给定一个起始位置（r，c） ，你可以沿着箭头防线在格子间行走。即如果（r,c）是一个左箭头，那么走到（r，c-1）;如果是右箭头那么走到（r，c+1）；如果是上箭头那么走到（r-1，c）；如果是下箭头那么走到（r+1，c）；每一行和每一列都是循环的，即如果走出边界，你会出现在另一侧。 一个完美的循环格是这样定义的：对于任意一个起始位置，你都可以i沿着箭头最终回到起始位置。如果一个循环格不满足完美，你可以随意修改任意一个元素的箭头直到完美。给定一个循环格，你需要计算最少需要修改多少个元素使其完美。 输入第一行两个整数R，C。表示行和列，接下来R行，每行C个字符LRUD，表示左右上下。 输出一个整数，表示最少需要修改多少个元素使得给定的循环格完美 输入样例3 4RRRDURLLLRRR 输出样例2 思路把每个点拆成2入点和出点，源点连接所有入点容量1费用0，出点连接汇点容量1费用0，每个点的入点连接原本能到达的点的出点容量为1费用为0，剩下三个方向连接改后可到达点的出点容量为1费用为1。跑最小费用流。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt; //using namespace std; const int MAX_N = 1000;const int MAX_M = 2000100;const int INF = 0x3f3f3f3f; int n, m;char maze[16][16]; const int dx[] = &#123;0, 0, -1, 1&#125;;const int dy[] = &#123;-1, 1, 0, 0&#125;; int id(int x, int y) &#123; return (x-1) * m + y;&#125; int oth(int x, int y) &#123; return id(x, y) + n * m;&#125; int change(char c) &#123; if (c == 'L') return 0; if (c == 'R') return 1; if (c == 'U') return 2; return 3;&#125; struct Edge &#123; Edge() &#123;&#125;; Edge(int a, int b, int c, int d) &#123; v = a; f = b; w = c; nxt = d; &#125;; int v, f, w, nxt;&#125;e[MAX_M];int lmt;int g[MAX_N];int nume;int src, sink; void addEdge(int u, int v, int c, int w) &#123; e[++nume] = Edge(v, c, w, g[u]); g[u] = nume; e[++nume] = Edge(u, 0, -w, g[v]); g[v] = nume;&#125; std::queue&lt;int&gt; que;bool inQue[MAX_N];int dist[MAX_N];int prev[MAX_N], pree[MAX_N]; bool findPath() &#123; while (!que.empty()) que.pop(); que.push(src); std::fill(dist, dist+MAX_N, INF); memset(inQue, 0, sizeof(inQue)); dist[src] = 0; inQue[src] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = g[u]; i; i = e[i].nxt) &#123; if (e[i].f &gt; 0 &amp;&amp; dist[u] + e[i].w &lt; dist[e[i].v]) &#123; dist[e[i].v] = dist[u] + e[i].w; prev[e[i].v] = u; pree[e[i].v] = i; if (!inQue[e[i].v]) &#123; inQue[e[i].v] = true; que.push(e[i].v); &#125; &#125; &#125; inQue[u] = false; &#125; if (dist[sink] &lt; INF) return true; else return false;&#125; int augment() &#123; int u = sink; int delta = INF; while (u != src) &#123; if (e[pree[u]].f &lt; delta) delta = e[pree[u]].f; u = prev[u]; &#125; u = sink; while (u != src) &#123; e[pree[u]].f -= delta; e[pree[u]^1].f += delta; u = prev[u]; &#125; return dist[sink] * delta;&#125; int mincostflow() &#123; int cur = 0, ans = 0; while (findPath()) &#123; cur += augment(); ans = cur; &#125; return ans;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;m); src = 0; sink = MAX_N-1; memset(g, 0, sizeof(g)); nume = 1; for (int i = 1; i &lt;= n; i++) scanf(\"%s\", maze[i]+1); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; addEdge(src, id(i, j), 1, 0); addEdge(oth(i, j), sink, 1, 0); for (int t = 0; t &lt; 4; t++) &#123; int tx = i + dx[t], ty = j + dy[t]; if (tx == 0) tx = n; if (tx &gt; n) tx = 1; if (ty == 0) ty = m; if (ty &gt; m) ty = 1; if (t == change(maze[i][j])) &#123; addEdge(id(i, j), oth(tx, ty), 1, 0); &#125; else &#123; addEdge(id(i, j), oth(tx, ty), 1, 1); &#125; &#125; &#125; &#125; printf(\"%d\\n\", mincostflow()); return 0;&#125;","path":"2018/05/14/bzoj3171tjoi2013-e5-be-aa-e7-8e-af-e6-a0-bc/","date":"05-14","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"最小费用流","slug":"最小费用流","permalink":"/tags/最小费用流/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"}]},{"title":"BZOJ1477青蛙的约会","text":"描述两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 输入输入只包括一行5个整数x，y，m，n，L，其中x≠y &lt; 2000000000，0 &lt; m、n &lt; 2000000000，0 &lt; L &lt; 2100000000。 输出输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行”Impossible” 输入样例1 2 3 4 5 输出样例4 思路扩展欧几里得模版题。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt; using namespace std; typedef long long ll; ll x, y, m, n, L; ll extend_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; else &#123; ll r = extend_gcd(b, a % b, y, x); y -= x * (a/b); return r; &#125;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%lld%lld%lld%lld%lld\", &amp;x, &amp;y, &amp;m, &amp;n, &amp;L); ll a = (n-m), b = L, c = x - y, x, y; ll d = extend_gcd(a, b, x, y); if (c % d) &#123; printf(\"Impossible\\n\"); &#125; else &#123; x = x * c / d; x = (x % b + b) % b; printf(\"%lld\\n\", x); &#125; return 0;&#125;","path":"2018/05/14/bzoj1477-e9-9d-92-e8-9b-99-e7-9a-84-e7-ba-a6-e4-bc-9a/","date":"05-14","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"数论","slug":"数论","permalink":"/tags/数论/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"/tags/扩展欧几里得/"}]},{"title":"BZOJ1412[ZJOI2009]狼和羊的故事","text":"描述“狼爱上羊啊爱的疯狂，谁让他们真爱了一场；狼爱上羊啊并不荒唐，他们说有爱就有方向．．．．．．” Orez听到这首歌，心想：狼和羊如此和谐，为什么不尝试羊狼合养呢？说干就干！ Orez的羊狼圈可以看作一个n*m个矩阵格子，这个矩阵的边缘已经装上了篱笆。可是Drake很快发现狼再怎么也是狼，它们总是对羊垂涎三尺，那首歌只不过是一个动人的传说而已。所以Orez决定在羊狼圈中再加入一些篱笆，还是要将羊狼分开来养。 通过仔细观察，Orez发现狼和羊都有属于自己领地，若狼和羊们不能呆在自己的领地，那它们就会变得非常暴躁，不利于他们的成长。 Orez想要添加篱笆的尽可能的短。当然这个篱笆首先得保证不能改变狼羊的所属领地，再就是篱笆必须修筑完整，也就是说必须修建在单位格子的边界上并且不能只修建一部分。 输入文件的第一行包含两个整数n和m。接下来n行每行m个整数，1表示该格子属于狼的领地，2表示属于羊的领地，0表示该格子不是任何一只动物的领地。 输出文件中仅包含一个整数ans，代表篱笆的最短长度。 输入样例2 22 21 1 输出样例2 思路源点和所有的狼相连容量为INF，所有的羊和汇点相连容量为INF，中间狼和所有的空白处以及羊相连容量为1，所有的空白处和羊相连容量为1，求最小割。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt; using namespace std; const int MAX_N = 11000;const int MAX_M = 500100;const int INF = 0x3f3f3f3f;int n, m;int maze[110][110];const int dx[] = &#123;0, 1, -1, 0&#125;;const int dy[] = &#123;1, 0, 0, -1&#125;; int id(int x, int y) &#123; return (x-1)*m + y;&#125; bool check(int x, int y) &#123; return 1 &lt;= x &amp;&amp; x &lt;= n &amp;&amp; 1 &lt;= y &amp;&amp; y &lt;= m;&#125; struct Edge &#123; int v, f, nxt;&#125;e[MAX_M];int src, sink, nume;int g[MAX_N]; void addEdge(int u, int v, int c) &#123; e[++nume].v = v; e[nume].f = c; e[nume].nxt = g[u]; g[u] = nume; e[++nume].v = u; e[nume].f = 0; e[nume].nxt = g[v]; g[v] = nume;&#125; void init() &#123; memset(g, 0, sizeof(g)); nume = 1;&#125; queue&lt;int&gt; que;bool vis[MAX_N];int dist[MAX_N]; void bfs() &#123; memset(dist, 0, sizeof(dist)); while (!que.empty()) que.pop(); vis[src] = true; que.push(src); while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = g[u]; i; i = e[i].nxt) &#123; if (e[i].f &amp;&amp; !vis[e[i].v]) &#123; que.push(e[i].v); dist[e[i].v] = dist[u] + 1; vis[e[i].v] = true; &#125; &#125; &#125;&#125; int dfs(int u, int delta) &#123; if (u == sink) &#123; return delta; &#125; else &#123; int ret = 0; for (int i = g[u]; delta &amp;&amp; i; i = e[i].nxt) &#123; if (e[i].f &amp;&amp; dist[e[i].v] == dist[u] + 1) &#123; int dd = dfs(e[i].v, min(e[i].f, delta)); e[i].f -= dd; e[i^1].f += dd; delta -= dd; ret += dd; &#125; &#125; return ret; &#125;&#125; int maxflow() &#123; int ret = 0; while (true) &#123; memset(vis, 0, sizeof(vis)); bfs(); if (!vis[sink]) return ret; ret += dfs(src, INF); &#125;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;m); init(); src = 0; sink = n * m + 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(\"%d\", &amp;maze[i][j]); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (maze[i][j] == 1) &#123; addEdge(src, id(i, j), INF); for (int t = 0; t &lt; 4; t++) &#123; int tx = i + dx[t], ty = j + dy[t]; if (!check(tx, ty)) continue; if (maze[tx][ty] != maze[i][j]) addEdge(id(i, j), id(tx, ty), 1); &#125; &#125; else if (maze[i][j] == 2) &#123; addEdge(id(i, j), sink, INF); &#125; else &#123; for (int t = 0; t &lt; 4; t++) &#123; int tx = i + dx[t], ty = j + dy[t]; if (!check(tx, ty)) continue; if (maze[tx][ty] != 1) &#123; addEdge(id(i, j), id(tx, ty), 1); &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\", maxflow()); return 0;&#125;","path":"2018/05/14/bzoj1412zjoi2009-e7-8b-bc-e5-92-8c-e7-be-8a-e7-9a-84-e6-95-85-e4-ba-8b/","date":"05-14","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"},{"name":"dinic","slug":"dinic","permalink":"/tags/dinic/"},{"name":"最小割","slug":"最小割","permalink":"/tags/最小割/"}]},{"title":"BZOJ3211花神游历各国","text":"描述.jpg) 输入.jpg) 输出每次x=1时，每行一个整数，表示这次旅行的开心度 输入样例41 100 5 551 1 22 1 21 1 22 2 31 1 4 输出样例1011111 思路看了别人的题解，发现并查集还能起到找到右侧第一个不为0和1的位置的作用，区间和用树状数组维护一下。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt; using namespace std; typedef long long ll; const int MAX_N = 1000010;int N, M; int par[MAX_N];ll a[MAX_N]; void init(int n) &#123; for (int i = 0; i &lt;= n+1; i++) par[i] = i;&#125; int find(int v) &#123; return par[v] = (par[v] == v ? v : find(par[v]));&#125; ll bit[MAX_N], n;void add(int i, ll x) &#123; while (i &lt;= n) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;ll sum(int i) &#123; ll s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;N); init(N); n = N; for (int i = 1; i &lt;= N; i++) &#123; scanf(\"%lld\", &amp;a[i]); add(i, a[i]); &#125; scanf(\"%d\", &amp;M); while (M--) &#123; int l, r, c; scanf(\"%d%d%d\", &amp;c, &amp;l, &amp;r); if (l &gt; r) swap(l, r); if (c == 1) &#123; printf(\"%lld\\n\", sum(r) - sum(l-1)); &#125; else if (c == 2) &#123; for (int i = find(l); i &lt;= r; i = find(i+1)) &#123; add(i, -a[i]); a[i] = (ll)sqrt(1.0*a[i]); add(i, a[i]); if (a[i] &lt;= 1) &#123; par[i] = find(i+1); &#125; &#125; &#125; &#125; return 0;&#125;","path":"2018/05/14/bzoj3211-e8-8a-b1-e7-a5-9e-e6-b8-b8-e5-8e-86-e5-90-84-e5-9b-bd/","date":"05-14","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"/tags/并查集/"},{"name":"树状数组","slug":"树状数组","permalink":"/tags/树状数组/"}]},{"title":"BZOJ2190[SDOI2008]仪仗队","text":"描述作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。 现在，C君希望你告诉他队伍整齐时能看到的学生人数。 输入共一个数N。 输出共一个数，即C君应看到的学生人数。 输入样例4 输出样例9 思路把方阵按副对角线分成两份，两边的可见数量应该是一样的，把左下角定为（0，0），可以发现能被看到的点其x，y互质，那么我们求出phi[2]到phi[n-1]的和乘2加3（（0，1）（1，0）（0，0））即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std; const int MAX_N = 40010; int N;int minDiv[MAX_N], phi[MAX_N], sum[MAX_N]; void genPhi() &#123; for (int i = 1; i &lt; MAX_N; i++) &#123; minDiv[i] = i; &#125; for (int i = 2; i * i &lt; MAX_N; i++) &#123; if (minDiv[i] == i) &#123; for (int j = i * i; j &lt; MAX_N; j += i) &#123; minDiv[j] = i; &#125; &#125; &#125; phi[1] = 1; for (int i = 2; i &lt; MAX_N; i++) &#123; phi[i] = phi[i / minDiv[i]]; if ((i / minDiv[i]) % minDiv[i] == 0) &#123; phi[i] *= minDiv[i]; &#125; else &#123; phi[i] *= minDiv[i] - 1; &#125; &#125;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); genPhi(); scanf(\"%d\", &amp;N); int ans = 0; for (int i = 2; i &lt;= N-1; i++) ans += phi[i]; ans = 2 * ans + 3; printf(\"%d\\n\", ans); return 0;&#125;","path":"2018/05/14/bzoj2190sdoi2008-e4-bb-aa-e4-bb-97-e9-98-9f/","date":"05-14","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"数论","slug":"数论","permalink":"/tags/数论/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"/tags/欧拉函数/"}]},{"title":"BZOJ1305[CQOI2009]dance跳舞","text":"描述一次舞会有n个男孩和n个女孩。每首曲子开始时，所有男孩和女孩恰好配成n对跳交谊舞。每个男孩都不会和同一个女孩跳两首（或更多）舞曲。有一些男孩女孩相互喜欢，而其他相互不喜欢（不会“单向喜欢”）。每个男孩最多只愿意和k个不喜欢的女孩跳舞，而每个女孩也最多只愿意和k个不喜欢的男孩跳舞。给出每对男孩女孩是否相互喜欢的信息，舞会最多能有几首舞曲？ 输入第一行包含两个整数n和k。以下n行每行包含n个字符，其中第i行第j个字符为’Y’当且仅当男孩i和女孩j相互喜欢。 输出仅一个数，即舞曲数目的最大值。 输入样例3 0YYYYYYYYY 输出样例3 思路把男生点i拆成i1，i2，把女生点拆成j1，j2，两者相互喜欢就把i1连向j1，容量为1，不喜欢就把i2连向j2，容量为1，再把i1和i2相连容量为k，j1和j2相连容量为k，源点和所有i1相连容量为当前能跳的舞曲数量，所有j1和汇点相连容量为当前能跳的舞曲数量。可以直接遍历检测也可以二分，只要最大流满流就合法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt; using namespace std; const int INF = 0x3f3f3f3f; struct Edge &#123; int v, f, nxt;&#125;e[1000000];int src, sink, g[1000], nume; void addEdge(int u, int v, int c) &#123; e[++nume].v = v; e[nume].f = c; e[nume].nxt = g[u]; g[u] = nume; e[++nume].v = u; e[nume].f = 0; e[nume].nxt = g[v]; g[v] = nume;&#125; void init() &#123; memset(g, 0, sizeof(g)); nume = 1;&#125; queue&lt;int&gt; que;bool vis[1000];int dist[1000]; void bfs() &#123; memset(dist, 0, sizeof(dist)); while (!que.empty()) que.pop(); vis[src] = true; que.push(src); while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = g[u]; i; i = e[i].nxt) &#123; if (e[i].f &amp;&amp; !vis[e[i].v]) &#123; que.push(e[i].v); dist[e[i].v] = dist[u] + 1; vis[e[i].v] = true; &#125; &#125; &#125;&#125; int dfs(int u, int delta) &#123; if (u == sink) &#123; return delta; &#125; else &#123; int ret = 0; for (int i = g[u]; delta &amp;&amp; i; i = e[i].nxt) &#123; if (e[i].f &amp;&amp; dist[e[i].v] == dist[u] + 1) &#123; int dd = dfs(e[i].v, min(e[i].f, delta)); e[i].f -= dd; e[i^1].f += dd; delta -= dd; ret += dd; &#125; &#125; return ret; &#125;&#125; int maxflow() &#123; int ret = 0; while (true) &#123; memset(vis, 0, sizeof(vis)); bfs(); if (!vis[sink]) return ret; ret += dfs(src, INF); &#125;&#125; int n, k; char maze[55][55]; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", maze[i]+1); &#125; int ans = 0; for (int i = 1; i &lt;= 50; i++) &#123; init(); src = 0, sink = 999; for (int j = 1; j &lt;= n; j++) &#123; for (int k = 1; k &lt;= n; k++) &#123; if (maze[j][k] == 'Y') &#123; addEdge(j, k+n, 1); &#125; else &#123; addEdge(j+2*n, k+3*n, 1); &#125; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; addEdge(src, j, i); addEdge(j+n, sink, i); addEdge(j, j+2*n, k); addEdge(j+3*n, j+n, k); &#125; if (maxflow() &lt; n * i) &#123; ans = i; break; &#125; &#125; printf(\"%d\\n\", ans-1); return 0;&#125;","path":"2018/05/13/bzoj1305cqoi2009dance-e8-b7-b3-e8-88-9e/","date":"05-13","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"},{"name":"dinic","slug":"dinic","permalink":"/tags/dinic/"},{"name":"最大流","slug":"最大流","permalink":"/tags/最大流/"}]},{"title":"BZOJ1013[JSOI2008]球形空间产生器sphere","text":"描述有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球 面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。 输入第一行是一个整数n(1&lt;=N=10)。接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。每一个实数精确到小数点 后6位，且其绝对值都不超过20000。 输出有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。每个实数精确到小数点 后3位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。 输入样例20.0 0.0-1.0 1.01.0 0.0 输出样例0.500 1.500 思路用前n个式子减去第n+1个式子，可以得到n个n元方程，高斯消元即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cmath&gt;# include &lt;algorithm&gt;using namespace std;const int MAX_N = 15;const double EPS = 1e-9;int N;double a[MAX_N][MAX_N];double ans[MAX_N];bool l[MAX_N];inline int solve(double a[][MAX_N], bool l[], double ans[], const int &amp;n) &#123; int res = 0, r = 0; for (int i = 0; i &lt; n; i++) l[i] = false; for (int i = 0; i &lt; n; i++) &#123; for (int j = r; j &lt; n; j++) &#123; if (fabs(a[j][i] &gt; EPS)) &#123; for (int k = i; k &lt;= n; k++) swap(a[j][k], a[r][k]); break; &#125; &#125; if (fabs(a[r][i]) &lt; EPS) &#123; ++res; continue; &#125; for (int j = 0; j &lt; n; j++) &#123; if (j != r &amp;&amp; fabs(a[j][i]) &gt; EPS) &#123; double tmp = a[j][i] / a[r][i]; for (int k = i; k &lt;= n; k++) a[j][k] -= tmp * a[r][k]; &#125; &#125; l[i] = true, ++r; &#125; for (int i = 0; i &lt; n; i++) &#123; if (l[i]) for (int j = 0; j &lt; n; j++) if (fabs(a[j][i]) &gt; EPS) ans[i] = a[j][n] / a[j][i]; &#125; return res;&#125;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;N); for (int i = 0; i &lt;= N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; scanf(\"%lf\", &amp;a[i][j]); &#125; &#125; for (int i = 0; i &lt; N; i++) &#123; double res = 0.0; for (int j = 0; j &lt; N; j++) &#123; res += a[N][j] * a[N][j] - a[i][j] * a[i][j]; a[i][j] = 2 * (a[N][j]-a[i][j]); &#125; a[i][N] = res; &#125; solve(a, l, ans, N); for (int i = 0; i &lt; N; i++) &#123; if (i) printf(\" \"); printf(\"%.3lf\", ans[i]); &#125; return 0;&#125;","path":"2018/05/12/bzoj1013jsoi2008-e7-90-83-e5-bd-a2-e7-a9-ba-e9-97-b4-e4-ba-a7-e7-94-9f-e5-99-a8sphere/","date":"05-12","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"高斯消元","slug":"高斯消元","permalink":"/tags/高斯消元/"}]},{"title":"BZOJ1088[SCOI2005]扫雷Mine","text":"描述相信大家都玩过扫雷的游戏。那是在一个n*m的矩阵里面有一些雷，要你根据一些信息找出雷来。万圣节到了 ，“余”人国流行起了一种简单的扫雷游戏，这个游戏规则和扫雷一样，如果某个格子没有雷，那么它里面的数字 表示和它8连通的格子里面雷的数目。现在棋盘是n×2的，第一列里面某些格子是雷，而第二列没有雷，如下图： 由于第一列的雷可能有多种方案满足第二列的数的限制，你的任务即根据第二列的信息确定第一列雷有多少种摆放 方案。 输入第一行为N，第二行有N个数，依次为第二列的格子中的数。（1&lt;= N &lt;= 10000） 输出一个数，即第一列中雷的摆放方案数。 输入样例21 1 输出样例2 思路确定第一个格子就能确定所有，所以只要用第一个格子有地雷和没有地雷两种情况分别dfs一下就行了。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt; using namespace std; const int MAX_N = 10010; int n;int a[MAX_N];int b[MAX_N]; int judge(int x, int i) &#123; if (i == n+1) &#123; return x == 0; &#125; b[i] = x; int cnt = a[i] - b[i] - b[i-1]; int res = judge(cnt, i+1); b[i] = 0; return res;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;n); memset(b, 0, sizeof(b)); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; int ans = 0; ans += judge(0, 1); if (a[1] != 0) ans += judge(1, 1); printf(\"%d\\n\", ans); return 0;&#125;","path":"2018/05/12/bzoj1088scoi2005-e6-89-ab-e9-9b-b7mine/","date":"05-12","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"dfs","slug":"dfs","permalink":"/tags/dfs/"}]},{"title":"BZOJ1188[HNOI2007]分裂游戏","text":"描述聪聪和睿睿最近迷上了一款叫做分裂的游戏。该游戏的规则试：共有n个瓶子，标号为0,1,2…..n-1,第i个瓶子中 装有p[i]颗巧克力豆，两个人轮流取豆子，每一轮每人选择3个瓶子。标号为i,j,k,并要保证i&lt;j,j&lt;=k且第i个瓶子 中至少要有1颗巧克力豆，随后这个人从第i个瓶子中拿走一颗豆子并在j,k中各放入一粒豆子（j可能等于k）。如 果轮到某人而他无法按规则取豆子，那么他将输掉比赛。胜利者可以拿走所有的巧克力豆！两人最后决定由聪聪先 取豆子，为了能够得到最终的巧克力豆，聪聪自然希望赢得比赛。他思考了一下，发现在有的情况下，先拿的人一 定有办法取胜，但是他不知道对于其他情况是否有必胜策略，更不知道第一步该如何取。他决定偷偷请教聪明的你 ，希望你能告诉他，在给定每个瓶子中的最初豆子数后是否能让自己得到所有巧克力豆，他还希望你告诉他第一步 该如何取，并且为了必胜，第一步有多少种取法？ 假定 1 &lt; n &lt; = 21,p[i] &lt; = 10000 输入输入文件第一行是一个整数t表示测试数据的组数， 接下来为t组测试数据（t&lt;=10）。 每组测试数据的第一行是瓶子的个数n， 接下来的一行有n个由空格隔开的非负整数，表示每个瓶子中的豆子数。 输出对于每组测试数据，输出包括两行， 第一行为用一个空格两两隔开的三个整数，表示要想赢得游戏， 第一步应该选取的3个瓶子的编号i,j,k， 如果有多组符合要求的解，那么输出字典序最小的一组。 如果无论如何都无法赢得游戏，那么输出用一个空格两两隔开的三个-1。 第二行表示要想确保赢得比赛，第一步有多少种不同的取法。 输入样例241 0 1 500030 0 1 输出样例0 2 31-1 -1 -10 思路瓶内为奇数个巧克力豆的情况对答案有影响，为偶数和没有是同样的情况。sg(x)表示第x个瓶子里有一个巧克力豆的局面的grundy值，取法就枚举判断即可。sg(i)的后继就是sg(j)^sg(k)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt; using namespace std; const int MAX_N = 25;int T, N;int a[MAX_N];int grundy[MAX_N]; int sg(int x) &#123; if (grundy[x] != -1) return grundy[x]; int vis[1000]; memset(vis, 0, sizeof(vis)); for (int i = x+1; i &lt; N; i++) &#123; for (int j = i; j &lt; N; j++) &#123; vis[sg(i)^sg(j)] = 1; &#125; &#125; for (int i = 0; ; i++) &#123; if (!vis[i]) return grundy[x] = i; &#125;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; memset(grundy, -1, sizeof(grundy)); int ans = 0, tot = 0; for (int i = 0; i &lt; N; i++) if (a[i] &amp; 1) ans ^= sg(i); for (int i = 0; i &lt; N; i++) &#123; for (int j = i + 1; j &lt; N; j++) &#123; for (int k = j; k &lt; N; k++) &#123; if ((ans ^ sg(i) ^ sg(j) ^ sg(k)) == 0) &#123; tot++; if (tot == 1) printf(\"%d %d %d\\n\", i, j, k); &#125; &#125; &#125; &#125; if (tot == 0) printf(\"-1 -1 -1\\n0\\n\"); else printf(\"%d\\n\", tot); &#125; return 0;&#125;","path":"2018/05/12/bzoj1188hnoi2007-e5-88-86-e8-a3-82-e6-b8-b8-e6-88-8f/","date":"05-12","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"nim游戏","slug":"nim游戏","permalink":"/tags/nim游戏/"},{"name":"sg函数","slug":"sg函数","permalink":"/tags/sg函数/"},{"name":"博弈论","slug":"博弈论","permalink":"/tags/博弈论/"}]},{"title":"BZOJ1090[SCOI2003]字符串折叠","text":"描述折叠的定义如下： 1. 一个字符串可以看成它自身的折叠。记作S  S 2. X(S)是X(X&gt;1)个S连接在一起的串的折叠。记作X(S)  SSSS…S(X个S)。 3. 如果A  A’, BB’，则AB  A’B’ 例如，因为3(A) = AAA, 2(B) = BB，所以3(A)C2(B)  AAACBB，而2(3(A)C)2(B)AAACAAACBB 给一个字符串，求它的最短折叠。例如AAAAAAAAAABABABCCD的最短折叠为：9(A)3(AB)CCD。 输入仅一行，即字符串S，长度保证不超过100。 输出仅一行，即最短的折叠长度。 输入样例NEERCYESYESYESNEERCYESYESYES 输出样例14 思路定义$dp[i][j]$为[l,j]区间的最短折叠长度，重复子串hash判断。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std; typedef unsigned long long ull; const int BASE = 13;const int MAX_N = 110; int N;char s[MAX_N];ull Hash[MAX_N], bin[MAX_N];int dp[MAX_N][MAX_N]; inline int idx(char c) &#123; return c - 'A'; &#125; inline int dig(int x) &#123; int res = 0; while (x) x/=10, res++; return res == 0 ? 1 : res; &#125; inline void init() &#123; bin[0] = 1; for (int i = 1; i &lt;= N; i++) bin[i] = bin[i-1] * BASE; for (int i = 1; i &lt;= N; i++) Hash[i] = Hash[i-1] * BASE + idx(s[i]);&#125; inline ull getHash(int l, int r) &#123; return Hash[r] - Hash[l-1] * bin[r-l+1]; &#125; inline bool judge(int l, int k, int r) &#123; if ((r - l + 1) % k) return false; int t1 = (r - l + 1) / k; ull t = getHash(l, l + t1 - 1); for (int i = l; i &lt;= r; i += t1) &#123; if (getHash(i, i + t1 - 1) != t) return false; &#125; return true;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%s\", s+1); N = strlen(s+1); init(); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; if (j + i - 1 &lt;= N) &#123; int l = j, r = j + i - 1; dp[l][r] = r - l + 1; for (int k = 1; k &lt;= i; k++) &#123; dp[l][r] = min(dp[l][r], dp[l][l+k-1] + dp[l+k][r]); if (judge(l, k, r)) dp[l][r] = min(dp[l][r], 2 + dig(k) + dp[l][l+(r-l+1)/k-1]); &#125; &#125; &#125; &#125; printf(\"%d\\n\", dp[1][N]); return 0;&#125;","path":"2018/05/11/bzoj1090scoi2003-e5-ad-97-e7-ac-a6-e4-b8-b2-e6-8a-98-e5-8f-a0/","date":"05-11","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"dp","slug":"dp","permalink":"/tags/dp/"},{"name":"区间dp","slug":"区间dp","permalink":"/tags/区间dp/"},{"name":"hash","slug":"hash","permalink":"/tags/hash/"}]},{"title":"BZOJ1068[SCOI2007]压缩","text":"描述给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。压缩后的字符串除了小 写字母外还可以（但不必）包含大写字母R与M，其中M标记重复串的开始，R重复从上一个M（如果当前位置左边没 有M，则从串的开始算起）开始的解压结果（称为缓冲串）。 bcdcdcdcd可以压缩为bMcdRR，下面是解压缩的过程 另一个例子是abcabcdabcabcdxyxyz可以被压缩为abcRdRMxyRz。 输入输入仅一行，包含待压缩字符串，仅包含小写字母，长度为n。 输出输出仅一行，即压缩后字符串的最短长度。 输入样例bcdcdcdcdxcdcdcdcd 输出样例12 思路看了别人的题解，定义$dp[i][j][1/0]​$表示区间[i,j]的最小压缩，1表示区间内无限制,0表示区间内没有M。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std; const int MAX_N = 55;char s[MAX_N];int n;int dp[MAX_N][MAX_N][2]; bool judge(char *str, int n) &#123; if (n &amp; 1) return false; int mi = n &gt;&gt; 1; for (int i = 0; i &lt; mi; i++) &#123; if (str[i] != str[mi+i]) return false; &#125; return true;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%s\", s); n = strlen(s); memset(dp, 0x3f, sizeof(dp)); for (int i = 0; i &lt; n; i++) dp[i][i][0] = dp[i][i][1] = 1; for (int w = 2; w &lt;= n; w++) &#123; for (int i = 0; i + w &lt;= n; i++) &#123; int j = i + w - 1; for (int k = i; k &lt; j; k++) &#123; dp[i][j][0] = min(dp[i][j][0], dp[i][k][0]+j-k); dp[i][j][1] = min(dp[i][j][1], dp[i][k][1]+1+dp[k+1][j][1]); &#125; if (judge(s+i, w)) dp[i][j][0] = min(dp[i][j][0], dp[i][(i+j)&gt;&gt;1][0]+1); dp[i][j][1] = min(dp[i][j][0], dp[i][j][1]); &#125; &#125; printf(\"%d\\n\", dp[0][n-1][1]); return 0;&#125;","path":"2018/05/11/bzoj1068scoi2007-e5-8e-8b-e7-bc-a9/","date":"05-11","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"dp","slug":"dp","permalink":"/tags/dp/"},{"name":"区间dp","slug":"区间dp","permalink":"/tags/区间dp/"}]},{"title":"BZOJ1079[SCOI2008]着色方案","text":"描述有n个木块排成一行，从左到右依次编号为1~n。你有k种颜色的油漆，其中第i种颜色的油漆足够涂ci个木块。 所有油漆刚好足够涂满所有木块，即c1+c2+…+ck=n。相邻两个木块涂相同色显得很难看，所以你希望统计任意两 个相邻木块颜色不同的着色方案。 输入第一行为一个正整数k，第二行包含k个整数c1, c2, … , ck。 输出输出一个整数，即方案总数模1,000,000,007的结果。 输入样例31 2 3 输出样例10 思路题目给的ci范围为1到5，考虑高维的dp，定义$dp[a][b][c][d][e][f]$为上一个取的是可以涂f个木块的颜色，当前有a个涂一个木块，b个涂两个木块，c个涂三个木块，d个涂四个木块，e个涂五个木块的颜色时的不同着色方案数，答案就是$dp[cnt1][cnt2][cnt3][cnt4][cnt5][0]$。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt; using namespace std; typedef long long ll; const int MOD = 1e9+7; int n;int cnt[6];ll dp[16][16][16][16][16][6];int vis[16][16][16][16][16][6]; ll dfs(int a, int b, int c, int d, int e, int f) &#123; if (vis[a][b][c][d][e][f]) return dp[a][b][c][d][e][f]; if (a+b+c+d+e == 0) return 1; ll ans = 0; if (a) ans += (a-(f==2)) * dfs(a-1, b, c, d, e, 1); if (b) ans += (b-(f==3)) * dfs(a+1, b-1, c, d, e, 2); if (c) ans += (c-(f==4)) * dfs(a, b+1, c-1, d, e, 3); if (d) ans += (d-(f==5)) * dfs(a, b, c+1, d-1, e, 4); if (e) ans += e * dfs(a, b, c, d+1, e-1, 5); vis[a][b][c][d][e][f] = 1; ans %= MOD; return dp[a][b][c][d][e][f] = ans;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; int x; scanf(\"%d\", &amp;x); cnt[x]++; &#125; printf(\"%lld\\n\", dfs(cnt[1], cnt[2], cnt[3], cnt[4], cnt[5], 0)); return 0;&#125;","path":"2018/05/10/bzoj1079scoi2008-e7-9d-80-e8-89-b2-e6-96-b9-e6-a1-88/","date":"05-10","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"dp","slug":"dp","permalink":"/tags/dp/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"/tags/记忆化搜索/"}]},{"title":"BZOJ1189[HNOI2007]紧急疏散evacuate","text":"描述发生了火警，所有人员需要紧急疏散！假设每个房间是一个N M的矩形区域。每个格子如果是’.’，那么表示这是一 块空地；如果是’X’，那么表示这是一面墙，如果是’D’，那么表示这是一扇门，人们可以从这儿撤出房间。已知门 一定在房间的边界上，并且边界上不会有空地。最初，每块空地上都有一个人，在疏散的时候，每一秒钟每个人都 可以向上下左右四个方向移动一格，当然他也可以站着不动。疏散开始后，每块空地上就没有人数限制了（也就是 说每块空地可以同时站无数个人）。但是，由于门很窄，每一秒钟只能有一个人移动到门的位置，一旦移动到门的 位置，就表示他已经安全撤离了。现在的问题是：如果希望所有的人安全撤离，最短需要多少时间？或者告知根本 不可能。 输入第一行是由空格隔开的一对正整数N与M，3&lt;=N &lt;=20，3&lt;=M&lt;=20， 以下N行M列描述一个N M的矩阵。其中的元素可为字符’.’、’X’和’D’，且字符间无空格。 输出只有一个整数K，表示让所有人安全撤离的最短时间， 如果不可能撤离，那么输出’impossible’（不包括引号）。 输入样例4 4XDXXD..XX.XXXXXX 输出样例3 思路很显然，时间不可能超过人的数量，所以我们可以二分时间。先bfs求所有人到门的最短距离，假设当前要检测的时间是t，那么我们把D的点拆成t份，第i份表示第i个时刻离开。把D的点和汇点相连容量为1，若某人到某D点的距离小于t，那么我们把这个点和符合时间的D的拆点相连，容量为1，最后把源点和所有有人的点相连容量为1。跑一个最大流，若流量等于人数则t是合法的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;queue&gt; using namespace std; const int MAX_N = 55;const int MAX_M = 52000;const int INF = 0x3f3f3f3f;char maze[MAX_N][MAX_N];int N, M, peo, doo, p[MAX_N][MAX_N], d[MAX_N][MAX_N], dis[90][410];int vis[MAX_N][MAX_N]; struct P &#123; int x, y, s; P() &#123;&#125; P(int _x, int _y, int _s) : x(_x), y(_y), s(_s) &#123;&#125; &#125;;const int dx[] = &#123;1, 0, -1, 0&#125;;const int dy[] = &#123;0, 1, 0, -1&#125;; void bfs(int x, int y) &#123; vis[x][y] = 1; int mark = d[x][y]; queue&lt;P&gt; q; q.push(P(x, y, 0)); while (!q.empty()) &#123; P now = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) &#123; int tx = now.x + dx[i], ty = now.y + dy[i]; if (tx &gt; N || tx &lt; 1 || ty &gt; M || ty &lt; 1 || vis[tx][ty] || maze[tx][ty] != '.') continue; vis[tx][ty] = 1; q.push(P(tx, ty, now.s+1)); if (p[tx][ty]) dis[mark][p[tx][ty]] = now.s+1; &#125; &#125;&#125; int head[MAX_M+1], h[MAX_M+1], cnt = 1, flo = 0;struct Data&#123;int to, nxt, v;&#125;e[6000000];void ins(int u, int v, int w) &#123; cnt++; e[cnt].to = v; e[cnt].v = w; e[cnt].nxt = head[u]; head[u] = cnt;&#125;void insert(int u, int v, int w) &#123; ins(u, v, w); ins(v, u, 0); &#125;bool bfs() &#123; memset(h, -1, sizeof(h)); queue&lt;int&gt; q; q.push(0); h[0] = 0; while (!q.empty()) &#123; int t = q.front(); q.pop(); int i = head[t]; while (i) &#123; if (e[i].v&amp;&amp;h[e[i].to]&lt;0) &#123; h[e[i].to] = h[t]+1; q.push(e[i].to); &#125; i = e[i].nxt; &#125; &#125; if (h[MAX_M] == -1) return 0; return 1;&#125; int dfs(int x, int f) &#123; if (x == MAX_M) return f; int i = head[x], w, used = 0; while (i) &#123; if (e[i].v&amp;&amp;h[e[i].to]==h[x]+1) &#123; w = f - used; w = dfs(e[i].to, min(w, e[i].v)); used += w; e[i].v -= w; e[i^1].v += w; if (used == f) return f; &#125; i = e[i].nxt; &#125; if (!used) h[x] = -1; return used;&#125;","path":"2018/05/10/bzoj1189hnoi2007-e7-b4-a7-e6-80-a5-e7-96-8f-e6-95-a3evacuate/","date":"05-10","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"bfs","slug":"bfs","permalink":"/tags/bfs/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"},{"name":"二分","slug":"二分","permalink":"/tags/二分/"},{"name":"dinic","slug":"dinic","permalink":"/tags/dinic/"}]},{"title":"cf489 div3","text":"A. Wrong Subtraction描述给一个数n和操作次数k，每次操作若当前数的最后一位为0就除10，否则减1，问k次操作后数为多少 输入第一行被操作数n和操作次数k 输出操作后的结构 输入样例512 4 1000000000 9 输出样例50 1 思路k很小，直接模拟 代码123456789101112131415161718192021222324252627# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;# include &lt;cmath&gt;using namespace std;int n, k;bool check(int x) &#123; int t = x; if (t &lt; 0) t = -t; int p = t % 10; return p == 0 ? true : false; &#125;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); cin &gt;&gt; n &gt;&gt; k; while (k--) &#123; if (check(n)) n /= 10; else n--; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0; &#125; B. Two-gram描述给一个字符串，输出出现最多的2个字符的连续子串 输入第一行字符串长度，第二行字符串 输出子串 输入样例7ABACABA 5ZZZAA 输出样例AB ZZ 思路暴力枚举，map计数。 代码123456789101112131415161718192021222324252627282930# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;# include &lt;cmath&gt;# include &lt;map&gt;using namespace std;int n;string s;map&lt;string, int&gt; mp;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; n-1; i++) &#123; mp\\[s.substr(i, 2)\\]++; &#125; int ma = 0; string ans = \"\"; for (auto it = mp.begin(); it != mp.end(); it++) &#123; if (it-&gt;second &gt; ma) &#123; ma = it-&gt;second; ans = it-&gt;first; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; C. Less or Equal描述给一个n长度的序列，输出一个数x（不一定在原序列中），在原本序列中有k个数小于等于x。不存在输出-1 输入第一行输入n和k 第二行输入序列 输出x 输入样例7 43 7 5 1 10 3 20 7 23 7 5 1 10 3 20 输出样例6 -1 思路把序列排序，看序列第k个，第k+1个，两个相等输出-1，还有就是题目要求的x范围不满足输出-1。其它输出a[k]就好。 代码 12345678910111213141516171819202122232425262728293031# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;# include &lt;cmath&gt;using namespace std;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d%d\", &amp;n, &amp;k)) &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a\\[i\\]); &#125; sort(a+1, a+1+n); if (k == 0) &#123; if (a\\[1\\] == 1) printf(\"-1\\\\n\"); else printf(\"%d\\\\n\", a\\[1\\]-1); continue; &#125; if (k == n) &#123; printf(\"%d\\\\n\", a\\[n\\]); continue; &#125; int t1 = a\\[k\\]; int t2 = a\\[k+1\\]; if (t1 == t2) printf(\"-1\\\\n\"); else printf(\"%d\\\\n\", t1); &#125; return 0;&#125; D. Divide by three, multiply by two描述给一个长度为n的序列，现在要求用原本的序列任意调换顺序，是的新序列中每一个数后面的数都是自己的三分之一或两倍。 输入第一行输入n 第二行输入n个数 输出变序后的序列 输入样例64 8 6 3 12 9 442 28 84 126 21000000000000000000 3000000000000000000 输出样例9 3 6 12 4 8 126 42 84 28 3000000000000000000 1000000000000000000 思路dfs暴力 代码12345678910111213141516171819202122232425262728293031# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;# include &lt;cmath&gt;using namespace std;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d%d\", &amp;n, &amp;k)) &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a\\[i\\]); &#125; sort(a+1, a+1+n); if (k == 0) &#123; if (a\\[1\\] == 1) printf(\"-1\\\\n\"); else printf(\"%d\\\\n\", a\\[1\\]-1); continue; &#125; if (k == n) &#123; printf(\"%d\\\\n\", a\\[n\\]); continue; &#125; int t1 = a\\[k\\]; int t2 = a\\[k+1\\]; if (t1 == t2) printf(\"-1\\\\n\"); else printf(\"%d\\\\n\", t1); &#125; return 0;&#125; E. Cyclic Components描述输入n个点和m条边，问有多少联通分量为一个环，无重边，有向图。 输入第一行n和m m行边 输出联通分量为环的数量 输入样例5 41 23 45 43 5 17 151 81 125 1111 99 1515 54 133 134 310 167 1016 714 314 417 6 输出样例1 2 思路并查集求联通分量，然后遍历每一个联通分量中的点，看是否全都只有两个出度，是则为环 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;map&gt;# include &lt;vector&gt;using namespace std;const int MAX_N = 200100;struct Data &#123; int to, nxt;&#125;e\\[MAX_N &lt;&lt; 1\\];int head\\[MAX_N\\], cnt = 1;void ins(int u, int v) &#123; cnt++; e\\[cnt\\].to = v; e\\[cnt\\].nxt = head\\[u\\]; head\\[u\\] = cnt;&#125;int par\\[MAX_N\\];void init(int n) &#123; for (int i = 1; i &lt;= n; i++) par\\[i\\] = i;&#125;int find(int x) &#123; if (par\\[x\\] == x) return x; return par\\[x\\] = find(par\\[x\\]);&#125;map&lt;int, vector&lt;int&gt; &gt; mp;int n, m, u, v;int ans = 0;bool check(vector&lt;int&gt; &amp;v) &#123; for (int i = 0; i &lt; v.size(); i++) &#123; int h = head\\[v\\[i\\]\\]; int cnt = 0; while (h) &#123; cnt++; h = e\\[h\\].nxt; &#125; if (cnt != 2) return false; &#125; return true;&#125;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;m); init(n); for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d\", &amp;u, &amp;v); ins(u, v); ins(v, u); int pu = find(u), pv = find(v); if (pu != pv) &#123; par\\[pv\\] = pu; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; int p = find(i); mp\\[p\\].push_back(i); &#125; for (auto it = mp.begin(); it != mp.end(); it++) &#123; vector&lt;int&gt; &amp;v = it-&gt;second; if (check(v)) ans++; &#125; printf(\"%d\\\\n\", ans); return 0;&#125; F. Consecutive Subsequence描述输入长度为n的序列，要求输出最长的严格递增1的子序列。 输入第一行输入n 第二行输入序列 输出第一行子序列长度 第二行子序列 输入样例73 3 4 7 5 6 8 61 3 5 2 4 6 410 9 8 7 96 7 8 3 4 5 9 10 11 输出样例42 3 5 6 21 4 11 61 2 3 7 8 9 思路用map存一下每个数的位置，从后向前dp下就好。 代码12345678910111213141516171819202122232425262728293031323334353637# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cmath&gt;# include &lt;cstring&gt;# include &lt;map&gt;# include &lt;vector&gt;using namespace std;const int MAX_N = 200010;int n;int a\\[MAX\\_N\\], nxt\\[MAX\\_N\\], len\\[MAX_N\\];map&lt;int, int&gt; mp;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d\", &amp;n)) &#123; mp.clear(); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a\\[i\\]); len\\[i\\] = 1; nxt\\[i\\] = -1; &#125; for (int i = n; i; i--) &#123; if (!mp.count(a\\[i\\]+1)) nxt\\[i\\] = -1; else nxt\\[i\\] = mp\\[a\\[i\\]+1\\], len\\[i\\] = len\\[nxt\\[i\\]\\]+1; mp\\[a\\[i\\]\\] = i; &#125; int ma = 0, s = 0; for (int i = 1; i &lt;= n; i++) if (len\\[i\\] &gt; ma) ma = len\\[i\\], s = i; printf(\"%d\\\\n\", ma); while (s != -1) &#123; printf(\"%d \", s); s = nxt\\[s\\]; &#125; printf(\"\\\\n\"); &#125; return 0; &#125;","path":"2018/05/08/cf489-div3/","date":"05-08","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"dp","slug":"dp","permalink":"/tags/dp/"},{"name":"并查集","slug":"并查集","permalink":"/tags/并查集/"},{"name":"dfs","slug":"dfs","permalink":"/tags/dfs/"}]},{"title":"BZOJ1818[Cqoi2010]内部白点","text":"描述无限大正方形网格里有n个黑色的顶点，所有其他顶点都是白色的（网格的顶点即坐标为整数的点，又称整点）。每秒钟，所有内部白点同时变黑，直到不存在内部白点为止。你的任务是统计最后网格中的黑点个数。 内部白点的定义：一个白色的整点P(x,y)是内部白点当且仅当P在水平线的左边和右边各至少有一个黑点（即存在x1 &lt; x &lt; x2使得(x1,y)和(x2,y)都是黑点），且在竖直线的上边和下边各至少有一个黑点（即存在y1 &lt; y &lt; y2使得(x,y1)和(x,y2)都是黑点）。 输入输入第一行包含一个整数n，即初始黑点个数。以下n行每行包含两个整数(x,y)，即一个黑点的坐标。没有两个黑点的坐标相同，坐标的绝对值均不超过1e9。 输出输出仅一行，包含黑点的最终数目。如果变色过程永不终止，输出-1。 输入样例40 22 0-2 00 -2 输出样例5 思路写了一下午的题，果然还是太菜。题目就是求横纵线段的交点数量再加上原本的点（有重复）。可以先预处理出每行的边界和每列的边界，需要离散化，其实就是求出所有的横纵线段，然后用扫描线从下到上扫一遍，用bit维护当前区间的列线段数量。细节比较多，re了一页。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;assert.h&gt; using namespace std; const int MAX_N = 100050;const int INF = 0x3f3f3f3f; struct P &#123; int x, y; &#125;p[MAX_N]; struct Bit &#123; int bit[MAX_N], n; void add(int i, int x) &#123; while (i &lt;= n) &#123; bit[i] += x; i += i &amp; -i; &#125; &#125; int sum(int i) &#123; int s = 0; while (i) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s; &#125;&#125;bt; int n;int hashX[MAX_N], hashY[MAX_N], lx[MAX_N], rx[MAX_N], ly[MAX_N], ry[MAX_N];int lenX, lenY;vector&lt;int&gt; y[MAX_N]; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d%d\", &amp;p[i].x, &amp;p[i].y); hashX[i] = p[i].x; hashY[i] = p[i].y; &#125; sort(hashX+1, hashX+1+n); lenX = unique(hashX+1, hashX+1+n) - (hashX+1); sort(hashY+1, hashY+1+n); lenY = unique(hashY+1, hashY+1+n) - (hashY+1); bt.n = lenX; for(int i = 1; i &lt;= lenX; i++) y[i].clear(); memset(lx, 0x3f, sizeof(lx)); memset(ly, 0x3f, sizeof(ly)); for (int i = 1; i &lt;= n; i++) &#123; p[i].x = lower_bound(hashX+1, hashX+1+lenX, p[i].x) - hashX; p[i].y = lower_bound(hashY+1, hashY+1+lenY, p[i].y) - hashY; lx[p[i].y] = min(lx[p[i].y], p[i].x); rx[p[i].y] = max(rx[p[i].y], p[i].x); ly[p[i].x] = min(ly[p[i].x], p[i].y); ry[p[i].x] = max(ry[p[i].x], p[i].y); &#125; for (int i = 1; i &lt;= lenX; i++) &#123; y[ly[i]].push_back(i); y[ry[i]+1].push_back(-i); &#125; int ans = 0; for (int i = 1; i &lt;= lenY; i++) &#123; for (int j = 0; j &lt; y[i].size(); j++) &#123; int v = y[i][j]; if (v &gt; 0) bt.add(v, 1); else bt.add(-v, -1); &#125; ans += (bt.sum(rx[i]) - bt.sum(lx[i]-1)); &#125; printf(\"%d\\n\", ans); return 0; &#125;","path":"2018/05/08/bzoj1818cqoi2010-e5-86-85-e9-83-a8-e7-99-bd-e7-82-b9/","date":"05-08","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"bit","slug":"bit","permalink":"/tags/bit/"},{"name":"扫描线","slug":"扫描线","permalink":"/tags/扫描线/"},{"name":"离散化","slug":"离散化","permalink":"/tags/离散化/"}]},{"title":"BZOJ2330[SCOI2011]糖果","text":"描述幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。 输入输入的第一行是两个整数N，K。 接下来K行，表示这些点需要满足的关系，每行3个数字，X，A，B。 如果X=1， 表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多； 如果X=2， 表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果； 如果X=3， 表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果； 如果X=4， 表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果； 如果X=5， 表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果； 输出输出一行，表示lxhgww老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出-1。 输入样例5 71 1 22 3 24 4 13 4 55 4 52 3 54 5 1 输出样例11 思路差分约束系统的模版题，不过和我刚开始学的不大一样，《挑战》上讲的是求最大值根据&gt;=建图求最短了，这个求的是最小值，那么就反过来根据&lt;=建图求最长路。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt; using namespace std; typedef long long ll; const int MAX_N = 100010;const int INF = 0x3f3f3f3f; struct Data &#123; int to, nxt, v; &#125;e[MAX_N &lt;&lt; 2];int cnt = 1, head[MAX_N]; void ins(int x, int y, int v) &#123; cnt++; e[cnt].to = y; e[cnt].v = v; e[cnt].nxt = head[x]; head[x] = cnt; &#125; int N, K, X, A, B;int dis[MAX_N], inq[MAX_N], cir[MAX_N];bool spfa() &#123; queue&lt;int&gt; q; for (int i = 0; i &lt;= N; i++) dis[i] = 1, q.push(i), inq[i] = 1, cir[i] = 0; while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = head[now]; i; i = e[i].nxt) &#123; if (dis[now]+e[i].v&gt;dis[e[i].to]) &#123; dis[e[i].to] = dis[now]+e[i].v; if (++cir[e[i].to]&gt;=N) return 0; if (!inq[e[i].to]) &#123; inq[e[i].to]=1; q.push(e[i].to); &#125; &#125; &#125; inq[now] = 0; &#125; return 1;&#125; int main () &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d\", &amp;N, &amp;K); for (int i = 0; i &lt; K; i++) &#123; scanf(\"%d%d%d\", &amp;X, &amp;A, &amp;B); switch(X) &#123; case 1: ins(A, B, 0); ins(B, A, 0); break; case 2: if (A==B) &#123;printf(\"-1\\n\"); return 0;&#125; ins(A, B, 1); break; case 3: ins(B, A, 0); break; case 4: if (A==B) &#123;printf(\"-1\\n\"); return 0;&#125; ins(B, A, 1); break; case 5: ins(A, B, 0); break; &#125; &#125; if (!spfa()) printf(\"-1\\n\"); else &#123; ll ans = 0; for (int i = 1; i &lt;= N; i++) ans += dis[i]; printf(\"%lld\\n\", ans); &#125; return 0; &#125;","path":"2018/05/08/bzoj2330scoi2011-e7-b3-96-e6-9e-9c/","date":"05-08","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"spfa","slug":"spfa","permalink":"/tags/spfa/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"差分约束系统","slug":"差分约束系统","permalink":"/tags/差分约束系统/"}]},{"title":"BZOJ1054[HAOI2008]移动玩具","text":"描述在一个4*4的方框内摆放了若干个相同的玩具，某人想将这些玩具重新摆放成为他心中理想的状态，规定移动 时只能将玩具向上下左右四个方向移动，并且移动的位置不能有玩具，请你用最少的移动次数将初始的玩具状态移 动到某人心中的目标状态。 输入前4行表示玩具的初始状态，每行4个数字1或0，1表示方格中放置了玩具，0表示没有放置玩具。接着是一个空 行。接下来4行表示玩具的目标状态，每行4个数字1或0，意义同上。 输出一个整数，所需要的最少移动次数。 输入样例1111000011100010 1010010110100101 输出样例4 思路网络流： 把第一个矩阵中为1的位置和超级源点相连，容量为1，费用为0，把第二个矩阵中为1的点和超级汇点相连，容量为1，费用为0，剩下可联通的点之间容量为无穷，费用为1。跑一遍最小费用流即可。 bfs+hash 把状态hash一下，bfs一下就行。 代码网络流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt; using namespace std; const int MAX_N = 800;const int INF = 0x3f3f3f3f; struct Data &#123; int to, from, nxt, c, w;&#125;e[MAX_N];int head[25], from[25], inq[25], dis[25], cnt = 1, ans = 0, flow = 0;void ins(int u, int v, int c, int w) &#123; cnt++; e[cnt].to = v; e[cnt].from = u; e[cnt].c = c; e[cnt].w = w; e[cnt].nxt = head[u]; head[u] = cnt;&#125; void insert(int u, int v, int c, int w) &#123; ins(u, v, c, w); ins(v, u, 0, -w); &#125; bool spfa() &#123; memset(inq, 0, sizeof(inq)); for (int i = 1; i &lt;= 17; i++) dis[i] = INF; queue&lt;int&gt; q; q.push(0); inq[0] = 1; dis[0] = 0; while (!q.empty()) &#123; int t = q.front(); q.pop(); int i = head[t]; while (i) &#123; if (e[i].c &gt; 0 &amp;&amp; dis[t] + e[i].w &lt; dis[e[i].to]) &#123; dis[e[i].to] = dis[t] + e[i].w; from[e[i].to] = i; if (!inq[e[i].to]) &#123; q.push(e[i].to); inq[e[i].to] = 1; &#125; &#125; i = e[i].nxt; &#125; inq[t] = 0; &#125; if (dis[17] == INF) return 0; return 1;&#125; void mcf() &#123; int i, x = INF; i = from[17]; while (i) &#123; x = min(x, e[i].c); i = from[e[i].from]; &#125; flow += x; i = from[17]; while (i) &#123; e[i].c -= x; e[i^1].c += x; ans += x * e[i].w; i = from[e[i].from]; &#125;&#125; const int dx[] = &#123;0, 1, 0, -1&#125;;const int dy[] = &#123;1, 0, -1, 0&#125;;char maze1[5][5];char maze2[5][5]; int pos(int x, int y) &#123; return (x-1)*4+y; &#125; bool check(int x, int y) &#123; return 1&lt;=x&amp;&amp;x&lt;=4&amp;&amp;1&lt;=y&amp;&amp;y&lt;=4; &#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); ans = flow = 0; for (int i = 1; i &lt;= 4; i++) scanf(\"%s\", maze1[i]+1); for (int i = 1; i &lt;= 4; i++) scanf(\"%s\", maze2[i]+1); for (int i = 1; i &lt;= 4; i++) &#123; for (int j = 1; j &lt;= 4; j++) &#123; if (maze1[i][j] == '1') insert(0, pos(i,j), 1, 0); if (maze2[i][j] == '1') insert(pos(i, j), 17, 1, 0); for (int t = 0; t &lt; 4; t++) &#123; int tx = i+dx[t], ty = j+dy[t]; if (check(tx, ty)) insert(pos(i, j), pos(tx, ty), INF, 1); &#125; &#125; &#125; while (spfa()) mcf(); printf(\"%d\\n\", ans); return 0; &#125; bfs+hash 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt; using namespace std; const int MAX_N = 10000000; struct S &#123; int ma[5][5]; int s; &#125;be, ed; int Hash(const S &amp;a) &#123; int res = 0; int len = 1; for (int i = 1; i &lt;= 4; i++) for (int j = 1; j &lt;= 4; j++) &#123; res += (len * a.ma[i][j]); len &lt;&lt;= 1; &#125; return res;&#125; const int dx[] = &#123;1, 0, -1, 0&#125;;const int dy[] = &#123;0, 1, 0, -1&#125;;int vis[MAX_N]; int bfs() &#123; queue&lt;S&gt; q; q.push(be); memset(vis, 0, sizeof(vis)); while (!q.empty()) &#123; S s = q.front(); q.pop(); if (Hash(s) == Hash(ed)) return s.s; for (int i = 1; i &lt;= 4; i++) &#123; for (int j = 1; j &lt;= 4; j++) &#123; if (s.ma[i][j]) &#123; for (int k = 0; k &lt; 4; k++) &#123; S s2 = s; int tx = i + dx[k]; int ty = j + dy[k]; if (tx &lt;= 0 || ty &lt;= 0 || 4 &lt; tx || 4 &lt; ty) continue; if (s2.ma[tx][ty]) continue; swap(s2.ma[i][j], s2.ma[tx][ty]); s2.s += 1; if (!vis[Hash(s2)]) &#123; vis[Hash(s2)] = 1; q.push(s2); &#125; &#125; &#125; &#125; &#125; &#125; return -1;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); for(int i=1;i&lt;=4;i++)for(int j=1;j&lt;=4;j++) scanf(\"%1d\", &amp;be.ma[i][j]); for(int i=1;i&lt;=4;i++)for(int j=1;j&lt;=4;j++) scanf(\"%1d\", &amp;ed.ma[i][j]); be.s = ed.s = 0; int ans = bfs(); printf(\"%d\\n\", ans); return 0; &#125;","path":"2018/05/06/bzoj1054haoi2008-e7-a7-bb-e5-8a-a8-e7-8e-a9-e5-85-b7/","date":"05-06","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"bfs","slug":"bfs","permalink":"/tags/bfs/"},{"name":"hash","slug":"hash","permalink":"/tags/hash/"},{"name":"最小费用流","slug":"最小费用流","permalink":"/tags/最小费用流/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"}]},{"title":"BZOJ1040[ZJOI2008]骑士","text":"描述Z国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各 界的赞扬。最近发生了一件可怕的事情，邪恶的Y国发动了一场针对Z国的侵略战争。战火绵延五百里，在和平环境 中安逸了数百年的Z国又怎能抵挡的住Y国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一 个真龙天子的降生，带领正义打败邪恶。骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一 些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出 征的。战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有 的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的 情况），并且，使得这支骑士军团最具有战斗力。为了描述战斗力，我们将骑士按照1至N编号，给每名骑士一个战 斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。 输入第一行包含一个正整数N，描述骑士团的人数。接下来N行，每行两个正整数，按顺序描述每一名骑士的战斗力 和他最痛恨的骑士。 输出应包含一行，包含一个整数，表示你所选出的骑士军团的战斗力。 输入样例310 220 330 1 输出样例30 思路边数等于点数，这是一个叫做基环树的dp题，dfs找环，删去环上一条边，设这条边相连的两个点为U，V，定义$f[x]$为以x为根且取x的最大权，定义$g[x]​$为以x为根且不取x的最大权值，分别以U，V为根dp一下，看g[u]和g[v]哪个大就选哪个。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;using namespace std;typedef long long ll;const int MAX_N = 1000010;struct Data &#123; int to, nxt; &#125;e[MAX_N &lt;&lt; 1];int head[MAX_N], cnt = 1;void ins(int u, int v) &#123; cnt++; e[cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt;&#125;int N, x, U, V, E, vis[MAX_N];ll v[MAX_N], f[MAX_N], g[MAX_N], ans = 0;void dfs(int x, int from) &#123; vis[x] = 1; for (int i = head[x]; i; i = e[i].nxt) &#123; if ((i^1) == from) continue; if (vis[e[i].to]) &#123; U = x; V= e[i].to; E = i; continue; &#125; dfs(e[i].to, i); &#125;&#125;void dp(int x, int from, int ban) &#123; f[x] = v[x]; g[x] = 0; for (int i = head[x]; i; i = e[i].nxt) &#123; if (i == ban || i == (ban^1)) continue; if ((i^1) == from) continue; dp(e[i].to, i, ban); f[x] += g[e[i].to]; g[x] += max(f[e[i].to], g[e[i].to]); &#125; &#125;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; i++) &#123; scanf(\"%lld%d\", &amp;v[i], &amp;x); ins(i, x); ins(x, i); &#125; for (int i = 1; i &lt;= N; i++) &#123; if (!vis[i]) &#123; dfs(i, 0); dp(U, 0, E); ll tmp = g[U]; dp(V, 0, E); tmp = max(tmp, g[V]); ans += tmp; &#125; &#125; printf(\"%lld\\n\", ans); return 0; &#125;","path":"2018/05/06/bzoj1040zjoi2008-e9-aa-91-e5-a3-ab/","date":"05-06","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"dfs","slug":"dfs","permalink":"/tags/dfs/"},{"name":"树形dp","slug":"树形dp","permalink":"/tags/树形dp/"}]},{"title":"BZOJ1862[Zjoi2006]GameZ游戏排名系统","text":"描述GameZ为他们最新推出的游戏开通了一个网站。世界各地的玩家都可以将自己的游戏得分上传到网站上。这样就可以看到自己在世界上的排名。得分越高，排名就越靠前。当两个玩家的名次相同时，先上传记录者优先。由于新游戏的火爆，网站服务器已经难堪重负。为此GameZ雇用了你来帮他们重新开发一套新的核心。排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回10条记录。 输入第一行是一个整数n（n&gt;=10）表示请求总数目。接下来n行每行包含了一个请求。请求的具体格式如下： +Name Score 上传最新得分记录。Name表示玩家名字，由大写英文字母组成，不超过10个字符。Score为最多8位的正整数。 ?Name 查询玩家排名。该玩家的得分记录必定已经在前面上传。 ?Index 返回自第Index名开始的最多10名玩家名字。Index必定合法，即不小于1，也不大于当前有记录的玩家总数。输入文件总大小不超过2M。 NOTE：用C++的fstream读大规模数据的效率较低 输出对于每条查询请求，输出相应结果。对于?Name格式的请求，应输出一个整数表示该玩家当前的排名。对于?Index格式的请求，应在一行中依次输出从第Index名开始的最多10名玩家姓名，用一个空格分隔。 输入样例20+ADAM 1000000+BOB 1000000+TOM 2000000+CATHY 10000000?TOM?1+DAM 100000+BOB 1200000+ADAM 900000+FRANK 12340000+LEO 9000000+KAINE 9000000+GRACE 8000000+WALT 9000000+SANDY 8000000+MICK 9000000+JACK 7320000?2?5?KAINE 输出样例2CATHY TOM ADAM BOBCATHY LEO KAINE WALT MICK GRACE SANDY JACK TOM BOBWALT MICK GRACE SANDY JACK TOM BOB ADAM DAM4 思路平衡树的模板题，但是对我而言写起来还是比较困难的。。用map来映射姓名和平衡树的节点，平衡树用splay实现。其中用了点小技巧求[l, r]排名的人的时候如果结点存的是成绩和时间的话树的结构和答案对不上，所以成绩我们存负的这样结点的排序和答案就对上了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;climits&gt; using namespace std; const int MAXM = 25000;template&lt;class T, size_t size&gt;struct MemoryPool &#123; T buf[size], *tail, *end; inline T *alloc() &#123; if (top) return st[--top]; if (tail != end) return tail++; return new T; &#125; MemoryPool() : tail(buf), end(buf+size), top(0) &#123;&#125; int top; T *st[size]; inline void recycle(T *x) &#123; if (top &gt; size) delete x; else st[top++] = x; &#125;&#125;; struct Splay &#123; struct Node &#123; Node *c[2], *fa, **root; map&lt;string, Node *&gt;::iterator it; pair&lt;int, int&gt; x; int size; inline Node *init(Node **root, Node *fa, const pair&lt;int, int&gt; &amp;x, const map&lt;std::string, Node *&gt;::iterator it) &#123; return this-&gt;fa = fa, this-&gt;root = root, this-&gt;it = it, this-&gt;x = x, this-&gt;size = 0, c[0] = c[1] = NULL, this; &#125; inline void recycle(MemoryPool&lt;Node, MAXM&gt; &amp;pool) &#123; if (c[0]) c[0]-&gt;recycle(pool), pool.recycle(c[0]), c[0] = NULL; if (c[1]) c[1]-&gt;recycle(pool), pool.recycle(c[1]), c[1] = NULL; &#125; inline void maintain() &#123; size = (c[0] ? c[0]-&gt;size : 0) + (c[1] ? c[1]-&gt;size : 0) + 1; &#125; inline int relation() &#123; return this == fa-&gt;c[1]; &#125; inline void rotate() &#123; Node *o = fa; int x = relation(); if (o-&gt;fa) o-&gt;fa-&gt;c[o-&gt;relation()] = this; fa = o-&gt;fa, o-&gt;c[x] = c[x^1]; if (c[x^1]) c[x^1]-&gt;fa = o; c[x^1] = o, o-&gt;fa = this, o-&gt;maintain(), maintain(); if (!fa) *root = this; &#125; inline Node *splay(Node *t = NULL) &#123; while (fa != t) &#123; if (fa-&gt;fa == t) rotate(); else if (relation() == fa-&gt;relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); &#125; return this; &#125; inline Node *pre() &#123; Node *v = splay()-&gt;c[0]; while (v-&gt;c[1]) v = v-&gt;c[1]; return v; &#125; inline Node *suc() &#123; Node *v = splay()-&gt;c[1]; while (v-&gt;c[0]) v = v-&gt;c[0]; return v; &#125; inline int rank() &#123; return c[0] ? c[0]-&gt;size : 0; &#125; &#125; *root; MemoryPool&lt;Node, MAXM&gt; pool; Splay(const std::map&lt;std::string, Node *&gt;::iterator null) : root(NULL) &#123; insert(std::make_pair(INT_MIN, INT_MIN), null), insert(std::make_pair(INT_MAX, INT_MAX), null); &#125; inline Node *insert(const std::pair&lt;int, int&gt; &amp;x, std::map&lt;std::string, Node *&gt;::iterator it) &#123; Node **v = &amp;root, *fa = NULL; while (*v) fa = *v, fa-&gt;size++, v = &amp;fa-&gt;c[x &gt; fa-&gt;x]; return *v = pool.alloc()-&gt;init(&amp;root, fa, x, it), (*v)-&gt;splay(); &#125; inline void erase(Node *v) &#123; Node *l = v-&gt;pre(), *r = v-&gt;suc(); r-&gt;splay(), l-&gt;splay(r); v-&gt;recycle(pool), pool.recycle(v), v = NULL, l-&gt;c[1] = NULL, l-&gt;size--, r-&gt;size--; &#125; inline Node *select(int k) &#123; int x = k; Node *v = root; while (v-&gt;rank() != x) &#123; if (v-&gt;rank() &gt; x) v = v-&gt;c[0]; else x -= v-&gt;rank() + 1, v = v-&gt;c[1]; &#125; return v-&gt;splay(); &#125; inline Node *select(int l, int r) &#123; Node *pre = select(l - 1), *suc = select(r + 1); return suc-&gt;splay(), pre-&gt;splay(suc)-&gt;c[1]; &#125; inline int size() &#123; return root-&gt;size - 2; &#125;&#125;; map&lt;std::string, Splay::Node *&gt; mp;Splay splay(mp.end());inline void dfs(Splay::Node *v, std::vector&lt;const std::string *&gt; &amp;vec) &#123; if (!v) return; dfs(v-&gt;c[0], vec); if (v-&gt;it != mp.end()) vec.push_back(&amp;v-&gt;it-&gt;first); dfs(v-&gt;c[1], vec);&#125;inline int parseInt(const std::string &amp;s) &#123; int x = 0; for (std::string::const_iterator it = s.begin(); it != s.end(); it++) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ((*it) ^ '0'); return x;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); ios::sync_with_stdio(0); cin.tie(0); int n; cin &gt;&gt; n; while (n--) &#123; string cmd; cin &gt;&gt; cmd; if (cmd[0] == '+') &#123; string name = cmd.substr(1, cmd.length()-1); int x; cin &gt;&gt; x; map&lt;string, Splay::Node *&gt;::iterator it = mp.find(name); if (it != mp.end()) splay.erase(it-&gt;second); else it = mp.insert(make_pair(name, static_cast&lt;Splay::Node *&gt;(NULL))).first; it -&gt; second = splay.insert(make_pair(-x, -n), it); &#125; else if (cmd[0] == '?') &#123; string arg = cmd.substr(1, cmd.length()-1); if (arg[0] &gt;= '0' &amp;&amp; arg[0] &lt;= '9') &#123; int x = parseInt(arg); Splay::Node *v = splay.select(x, std::min(splay.size(), x + 10 - 1)); vector&lt;const std::string *&gt; vec; dfs(v, vec); for (vector&lt;const string *&gt;::iterator it = vec.begin(); it != vec.end(); it++) cout &lt;&lt; **it &lt;&lt; (it == vec.end() - 1 ? '\\n' : ' '); &#125; else &#123; Splay::Node *v = mp[arg]; cout &lt;&lt; v-&gt;splay()-&gt;rank() &lt;&lt; '\\n'; &#125; &#125; &#125; return 0;&#125;","path":"2018/04/30/bzoj1862zjoi2006gamez-e6-b8-b8-e6-88-8f-e6-8e-92-e5-90-8d-e7-b3-bb-e7-bb-9f/","date":"04-30","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"splay","slug":"splay","permalink":"/tags/splay/"}]},{"title":"BZOJ1503[NOI2004]郁闷的出纳员","text":"描述OIER公司是一家大型专业化软件公司，有着数以万计的员工。作为一名出纳员，我的任务之一便是统计每位员工的 工资。这本来是一份不错的工作，但是令人郁闷的是，我们的老板反复无常，经常调整员工的工资。如果他心情好 ，就可能把每位员工的工资加上一个相同的量。反之，如果心情不好，就可能把他们的工资扣除一个相同的量。我 真不知道除了调工资他还做什么其它事情。工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位 员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员 工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘 了一位新员工，我就得为他新建一个工资档案。老板经常到我这边来询问工资情况，他并不问具体某位员工的工资 情况，而是问现在工资第k多的员工拿多少工资。每当这时，我就不得不对数万个员工进行一次漫长的排序，然后 告诉他答案。好了，现在你已经对我的工作了解不少了。正如你猜的那样，我想请你编一个工资统计程序。怎么样 ，不是很困难吧？ 输入第一行有两个非负整数n和min。n表示下面有多少条命令，min表示工资下界。 接下来的n行，每行表示一条命令。命令可以是以下四种之一： 名称 格式 作用 I命令 I_k 新建一个工资档案，初始工资为k。 如果某员工的初始工资低于工资下界，他将立刻离开公司。 A命令 A_k 把每位员工的工资加上k S命令 S_k 把每位员工的工资扣除k F命令 F_k 查询第k多的工资 _（下划线）表示一个空格，I命令、A命令、S命令中的k是一个非负整数，F命令中的k是一个正整数。 在初始时，可以认为公司里一个员工也没有。 I命令的条数不超过100000 A命令和S命令的总条数不超过100 F命令的条数不超过100000 每次工资调整的调整量不超过1000 新员工的工资不超过100000 输出输出行数为F命令的条数加一。 对于每条F命令，你的程序要输出一行，仅包含一个整数，为当前工资第k多的员工所拿的工资数， 如果k大于目前员工的数目，则输出-1。 输出文件的最后一行包含一个整数，为离开公司的员工的总数。 输入样例9 10I 60I 70S 50F 2I 30S 15A 5F 1F 2 输出样例1020-12 思路算得上是平衡树的模版题来，学习来一下大神的splay模版。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;climits&gt; template &lt;class T, size_t size&gt;struct MemoryPool &#123; T buf[size], *tail, *end; inline T *alloc() &#123; if (top) return st[--top]; if (tail != end) return tail++; return new T; &#125; MemoryPool() : tail(buf), end(buf + size), top(0) &#123;&#125; int top; T *st[size]; inline void recycle(T *x) &#123; if (top &gt; size) delete x; else st[top++] = x; &#125;&#125;;const int MAXN = 200200;#define null NULLtemplate&lt;class T, T INF&gt;struct Splay &#123; enum Relation &#123; L = 0, R = 1 &#125;; struct Node &#123; Node *child[2], *parent, **root; T value, lazy; int size, count; inline void init(Node *parent, const T &amp;value, Node **root) &#123; this-&gt;parent = parent, this-&gt;value = value, this-&gt;root = root, this-&gt;count = this-&gt;size = 1, this-&gt;lazy = 0, child[L] = child[R] = null; &#125; inline Relation relation() &#123; return this == parent-&gt;child[L] ? L : R; &#125; inline void recycle(MemoryPool&lt;Node, MAXN&gt; &amp;pool) &#123; if (child[L]) pool.recycle(child[L]); if (child[R]) pool.recycle(child[R]); &#125; inline void update(const T &amp;delta) &#123; if (this-&gt;value != INF &amp;&amp; this-&gt;value != -INF) this-&gt;value += delta; this-&gt;lazy += delta; &#125; inline void pushDown() &#123; if (lazy) &#123; if (child[L]) child[L]-&gt;update(lazy); if (child[R]) child[R]-&gt;update(lazy); lazy = 0; &#125; &#125; inline void maintain() &#123; pushDown(), size = count + (child[L] ? child[L]-&gt;size : 0) + (child[R] ? child[R]-&gt;size : 0); &#125; inline void rotate() &#123; pushDown(); Relation x = relation(); Node *oldParent = parent; if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent, oldParent-&gt;child[x] = child[x ^ 1]; if (child[x ^ 1]) child[x ^ 1]-&gt;parent = oldParent; child[x ^ 1] = oldParent, oldParent-&gt;parent = this, oldParent-&gt;maintain(), maintain(); if (!parent) *root = this; &#125; inline void splay(Node *targetParent = null) &#123; while (parent != targetParent) &#123; parent-&gt;pushDown(), pushDown(); if (parent-&gt;parent == targetParent) rotate(); else &#123; parent-&gt;parent-&gt;pushDown(); if (parent-&gt;relation() == relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); &#125; &#125; &#125; inline Node *precursor() &#123; splay(); Node *v = child[L]; while (v-&gt;child[R]) v = v-&gt;child[R]; return v; &#125; inline Node *successor() &#123; splay(); Node *v = child[R]; while (v-&gt;child[L]) v = v-&gt;child[L]; return v; &#125; inline int rank() &#123; return child[L] ? child[L]-&gt;size : 0; &#125; &#125; *root; MemoryPool&lt;Node, MAXN&gt; pool; Splay() : root(null) &#123; insert(INF), insert(-INF); &#125; inline Node *find(const T &amp;value) &#123; Node *v = root; while (v &amp;&amp; value != v-&gt;value) v-&gt;pushDown(), v = (value &lt; v-&gt;value ? v-&gt;child[L] : v-&gt;child[R]); return v ? (v-&gt;splay(), v) : null; &#125; inline Node *insert(const T &amp;value) &#123; Node *v = find(value); if (v) return v-&gt;count++, v-&gt;maintain(), v; Node **target = &amp;root, *parent = null; while (*target) parent = *target, parent-&gt;pushDown(), parent-&gt;size++, target = (value &lt; parent-&gt;value ? &amp;parent-&gt;child[L] : &amp;parent-&gt;child[R]); return *target = pool.alloc(), (*target)-&gt;init(parent, value, &amp;root), (*target)-&gt;splay(), root; &#125; inline const T &amp;select(int k) &#123; k++; Node *v = root; while (v-&gt;pushDown(), !(v-&gt;rank() &lt; k &amp;&amp; v-&gt;rank() + v-&gt;count &gt;= k)) v = (k &lt;= v-&gt;rank() ? v-&gt;child[L] : (k -= v-&gt;rank() + v-&gt;count, v-&gt;child[R])); return v-&gt;splay(), v-&gt;value; &#125; inline void erase(Node *l, Node *r) &#123; Node *pre = l-&gt;precursor(), *suc = r-&gt;successor(); pre-&gt;splay(), suc-&gt;splay(pre), suc-&gt;child[L]-&gt;recycle(pool); pool.recycle(suc-&gt;child[L]), suc-&gt;child[L] = null, suc-&gt;maintain(), pre-&gt;maintain(); &#125; inline void erase(Node *v) &#123; if (v-&gt;count &gt; 1) &#123; v-&gt;count--; &#125; else &#123; erase(v, v); &#125; &#125; inline void erase(const T &amp;l, const T &amp;r) &#123; Node *vl = find(l), *vr = find(r); if (!vl) vl = insert(l); if (!vr) vr = insert(r); erase(vl, vr); &#125; inline void update(const T &amp;value) &#123; root-&gt;update(value); &#125; inline int rank(const T &amp;value) &#123; Node *v = find(value); if (v) return v-&gt;rank(); else &#123; v = insert(value); const int ans = v-&gt;rank(); return erase(v), ans; &#125; &#125; inline int size() &#123; return root-&gt;size - 2; &#125;&#125;; int n, m, leave=0;char cmd[5];Splay&lt;int, INT_MAX&gt; splay;inline bool isValid(const char c) &#123; return c == 'I' || c == 'A' || c == 'S' || c == 'F'; &#125;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;m); leave = 0; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", cmd); while (!isValid(cmd[0])) scanf(\"%s\", cmd); int k; scanf(\"%d\", &amp;k); if (cmd[0] == 'I') &#123; if (k &gt;= m) splay.insert(k); &#125; else if (cmd[0] == 'A') &#123; splay.update(k); &#125; else if (cmd[0] == 'S') &#123; splay.update(-k); int old = splay.size(); splay.erase(-INT_MAX+1, m-1); leave += old - splay.size(); &#125; else if (cmd[0] == 'F') &#123; if (k &lt; 1 || k &gt; splay.size()) printf(\"-1\\n\"); else printf(\"%d\\n\", splay.select(splay.size()-k+1)); &#125; &#125; printf(\"%d\\n\", leave); return 0;&#125;","path":"2018/04/29/bzoj1503noi2004-e9-83-81-e9-97-b7-e7-9a-84-e5-87-ba-e7-ba-b3-e5-91-98/","date":"04-29","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"splay","slug":"splay","permalink":"/tags/splay/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}]},{"title":"BZOJ1877[SDOI2009]晨跑","text":"描述Elaxia最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等 等，不过到目前为止，他 坚持下来的只有晨跑。 现在给出一张学校附近的地图，这张地图中包含N个十字路口和M条街道，Elaxia只能从 一 个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia每天从寝室出发 跑到学校，保证寝室 编号为1，学校编号为N。 Elaxia的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以 在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路 口。Elaxia耐力不太好， 他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天 数尽量长。 除了练空手道，Elaxia其他时间 都花在了学习和找MM上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。 输入第一行：两个数N,M。表示十字路口数和街道数。 接下来M行，每行3个数a,b,c，表示路口a和路口b之间有条长度为c的街道（单向）。 N ≤ 200，M ≤ 20000。 输出两个数，第一个数为最长周期的天数，第二个数为满足最长天数的条件下最短的路程长 度。 输入样例7 101 2 11 3 12 4 13 4 14 5 14 6 12 5 53 6 65 7 16 7 1 输出样例2 11 思路很明显的最小费用流问题，把中间点拆成ab两点，a到b的容量为1，费用为0，就能保证原图每个中间点只经过一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt; using namespace std; const int INF = 0x3f3f3f3f;int head[40010], from[410], inq[410], dis[410], cnt=1, ans=0, flow=0;struct Data&#123;int to, from, nxt, c, w;&#125;e[100010];int n, m;void ins(int u, int v, int c, int w) &#123; cnt++; e[cnt].to=v; e[cnt].from=u; e[cnt].c=c; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;void insert(int u, int v, int c, int w) &#123; ins(u, v, c, w); ins(v, u, 0, -w);&#125;bool spfa() &#123; memset(inq, 0, sizeof(inq)); for(int i=1; i&lt;=2*n; i++) dis[i] = INF; queue&lt;int&gt; q; q.push(1); inq[1]=1; dis[1]=0; while(!q.empty()) &#123; int t = q.front(); q.pop(); int i = head[t]; while(i) &#123; if (e[i].c&gt;0&amp;&amp;dis[t]+e[i].w&lt;dis[e[i].to]) &#123; dis[e[i].to]=dis[t]+e[i].w; from[e[i].to]=i; if(!inq[e[i].to]) &#123; q.push(e[i].to); inq[e[i].to]=1; &#125; &#125; i=e[i].nxt; &#125; inq[t]=0; &#125; if(dis[2*n]==INF) return 0; return 1;&#125;void mcf() &#123; int i, x = INF; i = from[2*n]; while (i) &#123; x = min(x, e[i].c); i = from[e[i].from]; &#125; flow += x; i = from[2*n]; while (i) &#123; e[i].c-=x; e[i^1].c+=x; ans+=x*e[i].w; i=from[e[i].from]; &#125;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;m); ans = flow = 0; for (int i = 2; i &lt; n; i++) &#123; insert(i, i+n, 1, 0); &#125; insert(1, 1+n, INF, 0); insert(n, n+n, INF, 0); for (int i = 0; i &lt; m; i++) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); insert(u+n, v, 1, w); &#125; while (spfa()) mcf(); printf(\"%d %d\\n\", flow, ans); return 0;&#125;","path":"2018/04/28/bzoj1877sdoi2009-e6-99-a8-e8-b7-91/","date":"04-28","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"最小费用流","slug":"最小费用流","permalink":"/tags/最小费用流/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"}]},{"title":"BZOJ1007[HNOI2008]水平可见直线","text":"描述在xoy直角坐标平面上有n条直线L1,L2,…Ln,若在y值为正无穷大处往下看,能见到Li的某个子线段,则称Li为 可见的,否则Li为被覆盖的. 例如,对于直线: L1:y=x; L2:y=-x; L3:y=0 则L1和L2是可见的,L3是被覆盖的. 给出n条直线,表示成y=Ax+B的形式(|A|,|B|&lt;=500000),且n条直线两两不重合.求出所有可见的直线. 输入第一行为N(0 &lt; N &lt; 50000),接下来的N行输入Ai,Bi 输出从小到大输出可见直线的编号，两两中间用空格隔开,最后一个数字后面也必须有个空格 输入样例3-1 01 00 0 输出样例1 2 思路把直线按斜率从小到大排序，用单调栈维护一个直线交点横坐标不断上升的直线集合，最后栈内所有的直线都是可见的，因为从y无穷大出看到的是半个开口向上的凸包，直线的斜率是递增的，从左到右的顶点x坐标也是递增的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;cmath&gt;# include &lt;algorithm&gt;using namespace std;const double eps = 1e-8;int N;struct Line &#123; int n; double a, b; bool operator &lt; (const Line&amp; line) const &#123; return a &lt; line.a || ((abs(a-line.a)&lt;eps &amp;&amp; b &lt; line.b)); &#125;&#125;line[50010];Line st[50010];int top=0, vis[50010];double crossX(Line l1, Line l2) &#123; return (l2.b-l1.b) / (l1.a-l2.a);&#125;void insert(Line x) &#123; while (top) &#123; if (fabs(st[top].a-x.a) &lt; eps) top--; else if (top&gt;1&amp;&amp;crossX(x, st[top])&lt;=crossX(st[top], st[top-1])) top--; else break; &#125; st[++top] = x;&#125;int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; i++) &#123; scanf(\"%lf %lf\", &amp;line[i].a, &amp;line[i].b); line[i].n = i; &#125; sort(line+1, line+1+N); for (int i = 1; i &lt;= N; i++) &#123; insert(line[i]); &#125; for (int i = 1; i &lt;= top; i++) &#123; vis[st[i].n] = 1; &#125; for (int i = 1; i &lt;= N; i++) &#123; if (vis[i]) printf(\"%d \", i); &#125; return 0;&#125;","path":"2018/04/27/bzoj1007hnoi2008-e6-b0-b4-e5-b9-b3-e5-8f-af-e8-a7-81-e7-9b-b4-e7-ba-bf/","date":"04-27","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"单调栈","slug":"单调栈","permalink":"/tags/单调栈/"},{"name":"计算几何","slug":"计算几何","permalink":"/tags/计算几何/"}]},{"title":"BZOJ 1015[JSOI2008]星球大战starwar","text":"描述很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的 机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直 接或间接地连接。 但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划 地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首 领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每 一次打击之后反抗军占据的星球的连通快的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则 这两个星球在同一个连通块中）。 输入输入文件第一行包含两个整数，N (1 &lt; = N &lt; = 2M) 和M (1 &lt; = M &lt; = 200,000)，分别表示星球的 数目和以太隧道的数目。星球用 0 ~ N-1的整数编号。接下来的M行，每行包括两个整数X, Y，其中（0 &lt; = X &lt;&gt; Y 表示星球x和星球y之间有“以太”隧道，可以直接通讯。接下来的一行为一个整数k，表示将遭受攻击的星球的 数目。接下来的k行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这k个数互不相同，且都在0到n-1的范 围内。 输出第一行是开始时星球的连通块个数。接下来的K行，每行一个整数，表示经过该次打击后现存星球 的连通块个数。 输入样例8 130 11 66 55 00 61 22 33 44 57 17 27 63 6516357 输出样例111233 思路很明显的并查集题，不过并查集无法拆集合，由于题目可以离线处理我们先把删除的点保存起来反过来求，删除点就相当于增加点。数据量比较大，数组要开大点。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt; using namespace std; int head[400011], ans=0, cnt=0, n, m;int pa[400001], vis[400001], q[400001], len=0, res[400001], lenr=0;struct Data&#123;int to, nxt;&#125;e[400011];void ins(int u, int v) &#123; cnt++; e[cnt].to=v; e[cnt].nxt=head[u]; head[u]=cnt;&#125;void init(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; pa[i] = i; &#125;&#125;int find(int x) &#123; if (pa[x] == x) return x; return pa[x] = find(pa[x]);&#125;void unite(int u, int v) &#123; int x = find(u), y = find(v); if (x == y) return ; ans--; pa[x] = y;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); memset(vis, 0, sizeof(vis)); scanf(\"%d%d\", &amp;n, &amp;m); init(n); for (int i = 0; i &lt; m; i++) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); ins(x,y); ins(y,x); &#125; int k; scanf(\"%d\", &amp;k); for (int i = 0; i &lt; k; i++) &#123; int x; scanf(\"%d\", &amp;x); vis[x] = 1; q[len++] = x; &#125; ans = n-len; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i]) &#123; int t = head[i]; while (t) &#123; if (!vis[e[t].to]) unite(i, e[t].to); t = e[t].nxt; &#125; &#125; &#125; res[lenr++]=ans; for (int i = len-1; i &gt;= 0; i--) &#123; int t = head[q[i]]; vis[q[i]] = 0; ans++; while (t) &#123; if (!vis[e[t].to]) unite(q[i], e[t].to); t = e[t].nxt; &#125; res[lenr++]=ans; &#125; for (int i = lenr-1; i&gt;=0; i--) &#123; printf(\"%d\\n\", res[i]); &#125; return 0;&#125;","path":"2018/04/27/bzoj-1015jsoi2008-e6-98-9f-e7-90-83-e5-a4-a7-e6-88-98starwar/","date":"04-27","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"/tags/并查集/"},{"name":"离线处理","slug":"离线处理","permalink":"/tags/离线处理/"}]},{"title":"BZOJ1067[SCOI2007]降雨量","text":"描述我们常常会说这样的话：“X年是自Y年以来降雨量最多的”。它的含义是X年的降雨量不超过Y年，且对于任意 Y＜Z＜X，Z年的降雨量严格小于X年。例如2002，2003，2004和2005年的降雨量分别为4920，5901，2832和3890， 则可以说“2005年是自2003年以来最多的”，但不能说“2005年是自2002年以来最多的”由于有些年份的降雨量未 知，有的说法是可能正确也可以不正确的。 输入输入仅一行包含一个正整数n，为已知的数据。以下n行每行两个整数yi和ri，为年份和降雨量，按照年份从小 到大排列，即yi＜yi+1。下一行包含一个正整数m，为询问的次数。以下m行每行包含两个数Y和X，即询问“X年是 自Y年以来降雨量最多的。”这句话是必真、必假还是“有可能”。 输出对于每一个询问，输出true，false或者maybe。 输入样例62002 49202003 59012004 28322005 38902007 56092008 302452002 20052003 20052002 20072003 20072003 2004 输出样例falsetruefalsemaybefalse 思路用st表维护降雨量，查询的时候二分查找年份，思路简单就是细节比较多，比如防止查找的范围l&gt;r这种情况，还好没有调试多久。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std; const int MAX_N = 50010;int st[MAX_N][21];int a[MAX_N], b[MAX_N];int n, m; void init(int n) &#123; for (int j = 1; 1&lt;&lt;j &lt;= n; j++) for (int i = 1; i+(1&lt;&lt;j)-1 &lt; n; i++) st[i][j]=max(st[i][j-1], st[i+(1&lt;&lt;(j-1))][j-1]);&#125; int query(int L, int R) &#123; if (L&gt;R) return -0x7fffffff; int k = log(R-L+1)/log(2.0); return max(st[L][k], st[R-(1&lt;&lt;k)+1][k]);&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d %d\", &amp;a[i], &amp;b[i]); st[i][0] = b[i]; &#125; init(n); scanf(\"%d\", &amp;m); while (m--) &#123; int a1, b1; scanf(\"%d %d\", &amp;a1, &amp;b1); int p1 = lower_bound(a+1,a+1+n,a1)-a; int p2 = lower_bound(a+1,a+1+n,b1)-a; if (a[p1]==a1&amp;&amp;a[p2]==b1) &#123; if (b[p1]&lt;=b[p2]) &#123;printf(\"false\\n\"); continue;&#125; if (p2-p1 == a[p2]-a[p1]) &#123; if (query(p1+1,p2-1) &lt; b[p2]) &#123; printf(\"true\\n\"); continue; &#125; else &#123; printf(\"false\\n\"); continue; &#125; &#125; else &#123; if (query(p1+1,p2-1) &lt; b[p2]) &#123; printf(\"maybe\\n\"); continue; &#125; else &#123; printf(\"false\\n\"); continue; &#125; &#125; &#125; if (a[p1]==a1&amp;&amp;a[p2]!=b1) &#123; if (query(p1+1, p2-1) &gt;= b[p1]) &#123;printf(\"false\\n\"); continue;&#125; else &#123;printf(\"maybe\\n\"); continue;&#125; &#125; if (a[p1]!=a1&amp;&amp;a[p2]==b1) &#123; if (query(p1, p2-1) &lt; b[p2]) &#123;printf(\"maybe\\n\"); continue;&#125; else &#123;printf(\"false\\n\"); continue;&#125; &#125; if (a[p1]!=a1&amp;&amp;a[p2]!=b1) &#123; //if (query(p1,p2) &lt;= b[p2]) &#123;printf(\"maybe\\n\"); continue;&#125; //else &#123;printf(\"false\\n\"); continue;&#125; if (a1==b1) &#123;printf(\"false\\n\"); continue;&#125; else &#123;printf(\"maybe\\n\"); continue;&#125; &#125; &#125; return 0;&#125;","path":"2018/04/27/bzoj1067scoi2007-e9-99-8d-e9-9b-a8-e9-87-8f/","date":"04-27","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"RMQ","slug":"RMQ","permalink":"/tags/RMQ/"},{"name":"st表","slug":"st表","permalink":"/tags/st表/"},{"name":"二分","slug":"二分","permalink":"/tags/二分/"}]},{"title":"BZOJ2761[JLOI2011]不重复数字","text":"描述给出N个数，要求把其中重复的去掉，只保留第一次出现的数。 例如，给出的数为1 2 18 3 3 19 2 3 6 5 4，其中2和3有重复，去除后的结果为1 2 18 3 19 6 5 4。 输入输入第一行为正整数T，表示有T组数据。 接下来每组数据包括两行，第一行为正整数N，表示有N个数。第二行为要去重的N个正整数。 输出对于每组数据，输出一行，为去重后剩下的数字，数字之间用一个空格隔开。 输入样例2111 2 18 3 3 19 2 3 6 5 461 2 3 4 5 6 输出样例1 2 18 3 19 6 5 41 2 3 4 5 6 思路用平衡树维护一下就行，treap，splay都行。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt; using namespace std; struct Treap &#123; struct Node &#123; Node* ch[2]; int r, v; Node(int _v):v(_v)&#123;ch[0]=ch[1]=NULL;r=rand();&#125; ~Node() &#123;for(int i=0;i&lt;2;i++) if(ch[i]!=NULL) delete ch[i];&#125; bool operator &lt; (const Node&amp; rhs) const &#123; return r &lt; rhs.r; &#125; int cmp(int x) &#123; if(x==v) return -1; return (x&lt;v)?0:1; &#125; &#125;; Node* root; Treap() &#123;root=NULL;&#125; void clear() &#123; if (root != NULL) delete root; root = NULL; &#125; void rotate(Node* &amp;o, int d) &#123; Node *k=o-&gt;ch[d^1]; o-&gt;ch[d^1]=k-&gt;ch[d]; k-&gt;ch[d]=o; o=k; &#125; void insert(Node* &amp;o, int x) &#123; if(o==NULL) o=new Node(x); else &#123; int d=(x&lt;o-&gt;v?0:1); insert(o-&gt;ch[d], x); if(o-&gt;ch[d]-&gt;r&gt;o-&gt;r) rotate(o, d^1); &#125; &#125; void insert(int x) &#123;insert(root, x);&#125; void remove(Node* &amp;o, int x) &#123; int d=o-&gt;cmp(x); if(d==-1) &#123; Node* u = o; if(o-&gt;ch[0]!=NULL&amp;&amp;o-&gt;ch[1]!=NULL) &#123; int d2 = (o-&gt;ch[0]-&gt;r&gt;o-&gt;ch[1]-&gt;r?1:0); rotate(o, d2); remove(o-&gt;ch[d2], x); &#125; else &#123; if(o-&gt;ch[0]==NULL) o=o-&gt;ch[1]; else o=o-&gt;ch[0]; delete u; &#125; &#125; else remove(o-&gt;ch[d], x); &#125; void remove(int x) &#123;remove(root, x);&#125; int find(Node* o, int x) &#123; while(o!=NULL) &#123; int d=o-&gt;cmp(x); if (d==-1) return 1; else o=o-&gt;ch[d]; &#125; return 0; &#125; int find(int x) &#123;return find(root, x);&#125;&#125;; int T, N;vector&lt;int&gt; v;Treap t; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;T); while (T--) &#123; v.clear(); t.clear(); scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i++) &#123; int x; scanf(\"%d\", &amp;x); if (!t.find(x)) &#123; t.insert(x); v.push_back(x); &#125; &#125; for (int i = 0; i &lt; v.size(); i++) &#123; if (i &gt; 0) printf(\" \"); printf(\"%d\", v[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125;","path":"2018/04/26/bzoj2761jloi2011-e4-b8-8d-e9-87-8d-e5-a4-8d-e6-95-b0-e5-ad-97/","date":"04-26","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"treap","slug":"treap","permalink":"/tags/treap/"}]},{"title":"BZOJ1834[ZJOI2010]network 网络扩容","text":"描述给定一张有向图，每条边都有一个容量C和一个扩容费用W。这里扩容费用是指将容量扩大1所需的费用。 求： 1、在不扩容的情况下，1到N的最大流； 2、将1到N的最大流增加K所需的最小扩容费用。 输入第一行包含三个整数N,M,K，表示有向图的点数、边数以及所需要增加的流量。 接下来的M行每行包含四个整数u,v,C,W，表示一条从u到v，容量为C，扩容费用为W的边。 N&lt;=1000，M&lt;=5000，K&lt;=10 输出输出文件一行包含两个整数，分别表示问题1和问题2的答案。 输入样例5 8 21 2 5 82 5 9 95 1 6 25 1 1 81 2 8 72 5 4 91 2 1 11 4 2 1 输出样例13 19 思路第一个问题就是简单的最大流问题，第二题在第一题的残量网络上对每一个边增加一条容量为INF，费用为给出费用的边，再增加一个超级源点与点1相连，容量为k费用为0。从源点跑一遍最小费用流即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt; using namespace std; const int INF=0x3f3f3f3f;int n, m, k, cnt=1, ans=0, inq[1001], head[1001], h[1001], from[1001], dis[1001];struct Data&#123;int to, from, nxt, c, t, w;&#125;e[50010];void ins(int u, int v, int c, int w) &#123; cnt++; e[cnt].to=v; e[cnt].from=u; e[cnt].c=c; e[cnt].t=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;void insert(int u, int v, int c, int w) &#123; ins(u, v, c, w); ins(v, u, 0, -w);&#125;void ins2(int u, int v, int c, int w) &#123; cnt++; e[cnt].to=v; e[cnt].from=u; e[cnt].c=c; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt;&#125;void insert2(int u, int v, int c, int w) &#123; ins2(u, v, c, w); ins2(v, u, 0, -w);&#125;void build() &#123; int t = cnt; for (int i = 2; i &lt;= t; i++) if (i%2==0) insert2(e[i].from, e[i].to, INF, e[i].t);&#125;bool bfs() &#123; memset(h,-1,sizeof(h)); queue&lt;int&gt; q; q.push(1); h[1]=0; while(!q.empty()) &#123; int t = q.front(); q.pop(); int i = head[t]; while(i) &#123; if (e[i].c&gt;0&amp;&amp;h[e[i].to]==-1) &#123; h[e[i].to]=h[t]+1; q.push(e[i].to); &#125; i=e[i].nxt; &#125; &#125; if(h[n]==-1) return 0; return 1;&#125;int dfs(int x, int f) &#123; if (x==n) return f; int i=head[x], w, used=0; while(i) &#123; if (e[i].c&gt;0&amp;&amp;h[e[i].to]==h[x]+1) &#123; w=f-used; w=dfs(e[i].to, min(e[i].c, w)); used+=w; e[i].c-=w; e[i^1].c+=w; if(used==f) return f; &#125; i=e[i].nxt; &#125; if(!used) h[x]=-1; return used;&#125;void dinic()&#123; while(bfs()) ans+=dfs(1,INF);&#125;bool spfa() &#123; memset(inq, 0, sizeof(inq)); for(int i=0; i&lt;=n; i++) dis[i] = INF; queue&lt;int&gt; q; q.push(0); inq[0]=1; dis[0]=0; while(!q.empty()) &#123; int t = q.front(); q.pop(); int i = head[t]; while(i) &#123; if (e[i].c&gt;0&amp;&amp;dis[t]+e[i].w&lt;dis[e[i].to]) &#123; dis[e[i].to]=dis[t]+e[i].w; from[e[i].to]=i; if(!inq[e[i].to]) &#123; q.push(e[i].to); inq[e[i].to]=1; &#125; &#125; i=e[i].nxt; &#125; inq[t]=0; &#125; if(dis[n]==INF) return 0; return 1;&#125;void mcf() &#123; int i, x = INF; i = from[n]; while (i) &#123; x = min(x, e[i].c); i = from[e[i].from]; &#125; i = from[n]; while (i) &#123; e[i].c-=x; e[i^2].c+=x; ans+=x*e[i].w; i=from[e[i].from]; &#125;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d%d\", &amp;n,&amp;m,&amp;k); for(int i = 1; i &lt;= m; i++) &#123; int u, v, w, c; scanf(\"%d%d%d%d\", &amp;u,&amp;v,&amp;w,&amp;c); insert(u, v, w, c); &#125; dinic(); printf(\"%d \", ans); ans = 0; build(); ins(0,1,k,0); while (spfa()) mcf(); printf(\"%d\\n\", ans); return 0;&#125;","path":"2018/04/25/bzoj1834zjoi2010network-e7-bd-91-e7-bb-9c-e6-89-a9-e5-ae-b9/","date":"04-25","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"spfa","slug":"spfa","permalink":"/tags/spfa/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"最小费用流","slug":"最小费用流","permalink":"/tags/最小费用流/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"},{"name":"dinic","slug":"dinic","permalink":"/tags/dinic/"}]},{"title":"BZOJ1066[SCOI2007]蜥蜴","text":"描述在一个r行c列的网格地图中有一些高度不同的石柱，一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃 到边界外。 每行每列中相邻石柱的距离为1，蜥蜴的跳跃距离是d，即蜥蜴可以跳到平面距离不超过d的任何一个石 柱上。石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减1（如果仍然落在地图内部，则到达的石柱高度不 变），如果该石柱原来高度为1，则蜥蜴离开后消失。以后其他蜥蜴不能落脚。任何时刻不能有两只蜥蜴在同一个 石柱上。 输入输入第一行为三个整数r，c，d，即地图的规模与最大跳跃距离。以下r行为石竹的初始状态，0表示没有石柱 ，1~3表示石柱的初始高度。以下r行为蜥蜴位置，“L”表示蜥蜴，“.”表示没有蜥蜴。 输出输出仅一行，包含一个整数，即无法逃离的蜥蜴总数的最小值。 输入样例5 8 20000000002000000003211000200000000000000……..……....LLLL..……..…….. 输出样例1 思路可以用网络流来解决这题，把有数字的点拆成点A和点B若该点有蜥蜴那么让源和A点相连容量为1，若该点可以跑出去让B点和汇点相连容量为INF，然后让A和B相连容量为该点柱子的长度，dinic求个最大流，最大流就是能跑出去的蜥蜴的数量。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt; using namespace std; const int INF = 100000;int c, r, d, n;int head[10000], h[10000], cnt=1, num=0, flo=0;struct Data&#123;int to, nxt, v;&#125;e[1800000];int abs(int x) &#123; return x&gt;0?x:-x;&#125; void ins(int u, int v, int w) &#123; cnt++; e[cnt].to = v; e[cnt].v = w; e[cnt].nxt = head[u]; head[u] = cnt;&#125; bool bfs() &#123; memset(h, -1, sizeof(h)); queue&lt;int&gt; q; q.push(0); h[0] = 0; while (!q.empty()) &#123; int t = q.front(); q.pop(); int i = head[t]; while (i) &#123; if (e[i].v&amp;&amp;h[e[i].to]&lt;0) &#123; h[e[i].to] = h[t]+1; q.push(e[i].to); &#125; i = e[i].nxt; &#125; &#125; if (h[n+1] == -1) return 0; return 1;&#125; int dfs(int x, int f) &#123; if (x == n+1) return f; int i = head[x], w, used = 0; while (i) &#123; if (e[i].v&amp;&amp;h[e[i].to]==h[x]+1) &#123; w = f - used; w = dfs(e[i].to, min(w, e[i].v)); used += w; e[i].v -= w; e[i^1].v += w; if (used == f) return f; &#125; i = e[i].nxt; &#125; if (!used) h[x] = -1; return used;&#125; void dinic() &#123; while (bfs()) flo += dfs(0, INF);&#125; int id(int x, int y) &#123; return (x-1)*c+y;&#125;int oth(int i) &#123; return i + c*r;&#125; bool isOk(int x, int y) &#123; return (x-d)&lt;=0 || (x+d)&gt;r || (y-d)&lt;=0 || (y+d)&gt;c;&#125; bool check(int x, int y) &#123; return (0&lt;x)&amp;&amp;(x&lt;=r)&amp;&amp;(0&lt;y)&amp;&amp;(y&lt;=c);&#125; void addE(int x1, int y1, int x2, int y2) &#123; int id1 = id(x1, y1), id2 = id(x2, y2); ins(oth(id1), id2, INF); ins(id2, oth(id1), 0); //ins(oth(id2), id1, INF); ins(id1, oth(id2), 0);&#125; char s1[25][25];int nu[25][25];char s2[25][25]; void debug() &#123; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; cout &lt;&lt; nu[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; cout &lt;&lt; s2[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d%d%d\",&amp;r,&amp;c,&amp;d); n = 2*r*c; for(int i = 1; i &lt;= r; i++) &#123; scanf(\"%s\", s1[i]+1); for (int j = 1; j &lt;= c; j++) &#123; nu[i][j] = s1[i][j]-'0'; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; scanf(\"%s\", s2[i]+1); &#125; //debug(); //cout &lt;&lt; \"n: \" &lt;&lt; n &lt;&lt; endl; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; if (nu[i][j] &amp;&amp; isOk(i, j)) &#123; int x = id(i, j); //cout &lt;&lt; \"i: \" &lt;&lt; i &lt;&lt; \" j: \" &lt;&lt; j &lt;&lt; endl; ins(oth(x), n+1, INF); ins(n+1, oth(x), 0); &#125; if (nu[i][j] &amp;&amp; s2[i][j]=='L') &#123; num++; int x = id(i, j); //cout &lt;&lt; \"i: \" &lt;&lt; i &lt;&lt; \" j: \" &lt;&lt; j &lt;&lt; endl; ins(0, x, 1); ins(x, 0, 0); &#125; if (nu[i][j]) &#123; int x = id(i, j); //cout&lt;&lt;\"i:\"&lt;&lt;i&lt;&lt;\" j:\"&lt;&lt;j&lt;&lt;\" x:\"&lt;&lt;oth(x)&lt;&lt;endl; ins(x, oth(x), nu[i][j]); //cout &lt;&lt;\"i:\"&lt;&lt;i&lt;&lt;\" j:\"&lt;&lt;j&lt;&lt;\" nu:\"&lt;&lt;nu[i][j]&lt;&lt;endl; ins(oth(x), x, 0); for (int k = 1; k &lt;= r; k++) &#123; for (int t = 1; t &lt;= c; t++) &#123; //if (!check(k, t)) continue; if (k != i || t != j) &#123; int dis = abs(k-i) + abs(t-j); if (nu[k][t] &amp;&amp; dis&lt;=d) &#123; //cout &lt;&lt; \"i:\"&lt;&lt;i&lt;&lt;\" j:\"&lt;&lt;j;; //cout &lt;&lt; \" k:\"&lt;&lt;k&lt;&lt;\" t:\"&lt;&lt;t&lt;&lt;endl; addE(i, j, k, t); &#125; &#125; &#125; &#125; &#125; &#125; &#125; dinic(); //cout &lt;&lt; \"num: \" &lt;&lt; num &lt;&lt; \" flow: \" &lt;&lt; flo &lt;&lt; endl; printf(\"%d\\n\", num-flo); return 0;&#125;","path":"2018/04/24/bzoj1066scoi2007-e8-9c-a5-e8-9c-b4/","date":"04-24","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"},{"name":"dinic","slug":"dinic","permalink":"/tags/dinic/"}]},{"title":"BZOJ1934[Shoi2007]Vote 善意的投票","text":"描述幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。 我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？ 输入第一行只有两个整数n，m，保证有2≤n≤300，1≤m≤n(n-1)/2。其中n代表总人数，m代表好朋友的对数。文件第二行有n个整数，第i个整数代表第i个小朋友的意愿，当它为1时表示同意睡觉，当它为0时表示反对睡觉。接下来文件还有m行，每行有两个整数i，j。表示i，j是一对好朋友，我们保证任何两对i，j不会重复。 输出只需要输出一个整数，即可能的最小冲突数。 输入样例3 31 0 01 21 33 2 输出样例1 思路正儿八经思考的第一道网络流题目，把同意的人和s点相连容量为1，不同意的和t点相连容量为1，是朋友的互相连接容量为1。最终我们要把图变成两个不相交的集合，去掉的边的容量之和就是代价，要使代价最小就是求这个网络的最小割。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;cmath&gt; using namespace std; const int INF = 0x3f3f3f3f;int n, m, head[310], h[310], cnt=1, ans=0;struct Data&#123;int to, nxt, v;&#125;e[100001]; void ins(int u, int v, int w) &#123; cnt++; e[cnt].to = v; e[cnt].v = w; e[cnt].nxt = head[u]; head[u] = cnt;&#125; bool bfs() &#123; memset(h, -1, sizeof(h)); queue&lt;int&gt; q; q.push(0); h[0] = 0; while (!q.empty()) &#123; int t = q.front(); q.pop(); int i = head[t]; while (i) &#123; if (e[i].v&amp;&amp;h[e[i].to]&lt;0) &#123; h[e[i].to] = h[t]+1; q.push(e[i].to); &#125; i = e[i].nxt; &#125; &#125; if (h[n+1] == -1) return 0; return 1;&#125; int dfs(int x, int f) &#123; if (x == n+1) return f; int i = head[x], used=0, w; while (i) &#123; if (e[i].v&amp;&amp;h[e[i].to]==h[x]+1) &#123; w = f - used; w = dfs(e[i].to, min(w, e[i].v)); used += w; e[i].v -= w; e[i^1].v += w; if (used == f) return f; &#125; i = e[i].nxt; &#125; if (!used) h[x] = -1; return used;&#125; void dinic() &#123; while (bfs()) ans += dfs(0, INF);&#125; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); int x, y; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;x); if (x == 1) &#123;ins(0, i, 1); ins(i, 0, 0);&#125; else &#123;ins(n+1, i, 0); ins(i, n+1, 1);&#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\", &amp;x, &amp;y); ins(x, y, 1); ins(y, x, 1); &#125; dinic(); printf(\"%d\\n\", ans); return 0;&#125;","path":"2018/04/23/bzoj1934shoi2007vote-e5-96-84-e6-84-8f-e7-9a-84-e6-8a-95-e7-a5-a8/","date":"04-23","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"/tags/网络流/"},{"name":"dinic","slug":"dinic","permalink":"/tags/dinic/"}]},{"title":"BZOJ1076[SCOI2008]奖励关","text":"描述你正在玩你最喜欢的电子游戏，并且刚刚进入一个奖励关。在这个奖励关里，系统将依次随机抛出k次宝物， 每次你都可以选择吃或者不吃（必须在抛出下一个宝物之前做出选择，且现在决定不吃的宝物以后也不能再吃）。 宝物一共有n种，系统每次抛出这n种宝物的概率都相同且相互独立。也就是说，即使前k-1次系统都抛出宝物1（ 这种情况是有可能出现的，尽管概率非常小），第k次抛出各个宝物的概率依然均为1/n。 获取第i种宝物将得到Pi 分，但并不是每种宝物都是可以随意获取的。第i种宝物有一个前提宝物集合Si。只有当Si中所有宝物都至少吃过 一次，才能吃第i种宝物（如果系统抛出了一个目前不能吃的宝物，相当于白白的损失了一次机会）。注意，Pi可 以是负数，但如果它是很多高分宝物的前提，损失短期利益而吃掉这个负分宝物将获得更大的长期利益。 假设你 采取最优策略，平均情况你一共能在奖励关得到多少分值？ 输入第一行为两个正整数k和n，即宝物的数量和种类。以下n行分别描述一种宝物，其中第一个整数代表分值，随 后的整数依次代表该宝物的各个前提宝物（各宝物编号为1到n），以0结尾。 输出输出一个实数，保留六位小数，即在最优策略下平均情况的得分。 输入样例1 21 02 0 输出样例1.500000 思路第一道概率dp题 代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt; using namespace std; double f[101][1&lt;&lt;17];int v[20], d[20], p[20];int n, k; int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); for (int i = 1; i &lt;= 16; i++) p[i] = 1&lt;&lt;(i-1); scanf(\"%d%d\", &amp;k, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;v[i]); int x; while (scanf(\"%d\", &amp;x) &amp;&amp; x) d[i] |= p[x]; &#125; for (int i = k; i; i--) &#123; for (int j = 0; j &lt; p[n+1]; j++) &#123; for (int t = 1; t &lt;= n; t++) &#123; if ((j&amp;d[t])==d[t]) f[i][j]+=max(f[i+1][j],f[i+1][j|p[t]]+v[t]); else f[i][j] += f[i+1][j]; &#125; f[i][j] /= n; &#125; &#125; printf(\"%.6lf\\n\", f[1][0]); return 0;&#125;","path":"2018/04/23/bzoj1076scoi2008-e5-a5-96-e5-8a-b1-e5-85-b3/","date":"04-23","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"概率dp","slug":"概率dp","permalink":"/tags/概率dp/"},{"name":"状压dp","slug":"状压dp","permalink":"/tags/状压dp/"}]},{"title":"cf475 div2","text":"菜得再不能稳定出一半题就要掉分了！！！ A. Splits题意：给一个数n，构造非增序列，使得序列中的数之和等于n，问这种第一个数数量不同的序列能构造几个。 思路：找规律得答案为n/2+1。 代码 12345678910111213141516171819202122# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;string&gt;# include &lt;map&gt;# include &lt;iostream&gt;# include &lt;cmath&gt;# include &lt;vector&gt;# include &lt;set&gt;# include &lt;algorithm&gt;# include &lt;queue&gt;typedef long long ll;using namespace std;const int N = 1010;int n;int main() &#123; cin &gt;&gt; n; cout &lt;&lt; 1+n/2 &lt;&lt; endl; return 0;&#125; B. Messages题意：有n个信，每个信的价值都是A，每封信都有一个到达时间，信到达之后可以选择接收，也可以选择不接收，信只要到达可以随时选择接收，信被接收后直接获得信的价值，若不接收每过一天信的价值减少B，到达的信若没有接收每过一天会提供C的价值，到最后一天必须接收所有的信，问能获得的最大价值是多少。 思路：可以知道信和信直接是不会影响的可以计算每一封信能提供的收益为A+(C-B)*x，x为信停留的天数，可以知道只有当C大于B时信的停留才能提供更多的价值，否则就选择直接接收。 代码 1234567891011121314151617181920212223242526272829# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;# include &lt;cmath&gt;# include &lt;cstring&gt;# include &lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;int n, A, B, C, T;int t;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d %d %d %d %d\", &amp;n, &amp;A, &amp;B, &amp;C, &amp;T)) &#123; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;t); if (C &gt; B) ans += A + (C - B) * (T-t); else ans += A; &#125; printf(\"%d\\\\n\", ans); &#125; return 0;&#125;","path":"2018/04/21/cf475-div2/","date":"04-21","excerpt":"","tags":[{"name":"找规律","slug":"找规律","permalink":"/tags/找规律/"}]},{"title":"BZOJ1821[JSOI2010]Group 部落划分 Group","text":"描述聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。 不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了N个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了K个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法： 对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。 输入第一行包含两个整数N和K(1&lt; = N &lt; = 1000,1&lt; K &lt; = N)，分别代表了野人居住点的数量和部落的数量。 接下来N行，每行包含两个正整数x,y，描述了一个居住点的坐标(0 &lt; =x, y &lt; =10000) 输出输出一行，为最优划分时，最近的两个部落的距离，精确到小数点后两位。 输入样例4 20 00 11 11 0 输出样例1.00 思路先跑n^2得到所有的距离，从小到大排序，用并查集维护点的联通，从小边开始合并点当出现第K个集合的时候输出当前最小的距离。（简单来讲就是kruskal算法跑到第n-k+1条边） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std;typedef long long ll; const int MAX_N = 1010; int par[MAX_N*MAX_N]; void init(int n) &#123; for (int i = 1; i &lt;= n; i++) par[i] = i;&#125; int find(int x) &#123; if (x == par[x]) return x; return par[x] = find(par[x]);&#125; struct Data &#123; int x, y; double dis; bool operator &lt; (const Data&amp; data) const &#123; return dis &lt; data.dis; &#125;&#125;data[MAX_N*MAX_N];int len = 0; int N, K;int x[MAX_N], y[MAX_N]; double distance2(double x1, double y1, double x2, double y2) &#123; return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d %d\", &amp;N, &amp;K)) &#123; len = 0; for (int i = 1; i &lt;= N; i++) scanf(\"%d %d\", &amp;x[i], &amp;y[i]); for (int i = 1; i &lt;= N; i++) for (int j = i+1; j &lt;= N; j++) &#123; len++; data[len].x = i; data[len].y = j; data[len].dis = distance2(x[i], y[i], x[j], y[j]); &#125; sort(data+1, data+1+len); init(N); int cnt = N; int i = 0; for (i = 1; i &lt;= len; i++) &#123; if (find(data[i].x) != find(data[i].y)) &#123; int px = find(data[i].x), py = find(data[i].y); cnt--; par[px] = py; &#125; if (cnt &lt; K) break; &#125; printf(\"%.2lf\\n\", sqrt(data[i].dis)); &#125; return 0;&#125;","path":"2018/04/19/bzoj1821jsoi2010group-e9-83-a8-e8-90-bd-e5-88-92-e5-88-86-group/","date":"04-19","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"kruskal","slug":"kruskal","permalink":"/tags/kruskal/"},{"name":"并查集","slug":"并查集","permalink":"/tags/并查集/"},{"name":"贪心","slug":"贪心","permalink":"/tags/贪心/"}]},{"title":"BZOJ3038上帝造题的七分钟2","text":"描述XLk觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。 “第一分钟，X说，要有数列，于是便给定了一个正整数数列。 第二分钟，L说，要能修改，于是便有了对一段数中每个数都开平方(下取整)的操作。 第三分钟，k说，要能查询，于是便有了求一段数的和的操作。 第四分钟，彩虹喵说，要是NOIP难度，于是便有了数据范围。 第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。 第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过64位有符号整数类型的表示范围的限制。 第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。” ——《上帝造题的七分钟·第二部》 所以这个神圣的任务就交给你了。 输入第一行一个整数n，代表数列中数的个数。 第二行n个正整数，表示初始状态下数列中的数。 第三行一个整数m，表示有m次操作。 接下来m行每行三个整数k,l,r，k=0表示给[l,r]中的每个数开平方(下取整)，k=1表示询问[l,r]中各个数的和。 输出对于询问操作，每行输出一个回答。 输入样例101 2 3 4 5 6 7 8 9 1050 1 101 1 101 1 50 5 81 4 8 输出样例1976 思路普通线段树，不用lazy，但是要加特判，当区间和等于区间长度就不用继续向下更新。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;vector&gt;# include &lt;map&gt;# include &lt;cmath&gt;# include &lt;algorithm&gt;using namespace std;typedef long long ll;# define lc(x) (x &lt;&lt; 1)# define rc(x) (x &lt;&lt; 1 | 1)# define lson l, m, rt &lt;&lt; 1# define rson m+1, r, rt &lt;&lt; 1 | 1const int MAX_N = 100010;const int INF = 0x3f3f3f3f;ll sum[MAX_N &lt;&lt; 2];int N, Q;void push_up(int rt) &#123; sum[rt] = sum[lc(rt)] + sum[rc(rt)];&#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; scanf(\"%lld\", &amp;sum[rt]); return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); push_up(rt);&#125;void update(int L, int R, int l, int r, int rt) &#123; if (l == r) &#123; sum[rt] = (int)sqrt(sum[rt]); return ; &#125; if (L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; sum[rt] == r - l + 1) return ; int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L, R, lson); if (m &lt; R) update(L, R, rson); push_up(rt); return ;&#125;ll query(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; int m = (l + r) &gt;&gt; 1; ll res = 0; if (L &lt;= m) res += query(L, R, lson); if (m &lt; R) res += query(L, R, rson); return res;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); // int kcase = 0; while (~scanf(\"%d\", &amp;N)) &#123; build(1, N, 1); scanf(\"%d\", &amp;Q); while (Q--) &#123; int t, l, r; scanf(\"%d %d %d\", &amp;t, &amp;l, &amp;r); if (l &gt; r) swap(l, r); if (t == 1) &#123; printf(\"%lld\\n\", query(l, r, 1, N, 1)); &#125; else &#123; update(l, r, 1, N, 1); &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125;","path":"2018/04/19/bzoj3038-e4-b8-8a-e5-b8-9d-e9-80-a0-e9-a2-98-e7-9a-84-e4-b8-83-e5-88-86-e9-92-9f2/","date":"04-19","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"/tags/线段树/"}]},{"title":"BZOJ1087[SCOI2005]互不侵犯King","text":"描述在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上 左下右上右下八个方向上附近的各一个格子，共8个格子。 输入只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N） 输出方案数。 输入样例3 2 输出样例16 思路用二进制表示一行哪些格子用king，先预处理出合法的状态对i状态来讲只有当$i\\&amp;(i&gt;&gt;1)==0$时当前状态合法，对于i状态和j状态只有当$(i\\&amp;j)!=0 \\cap (i\\&amp;(j&gt;&gt;1))!=0 \\cap (i\\&amp;(j&lt;&lt;1))!=0$时i状态可以转移到j状态，定义状态$dp[i][j][k]$为第i行j状态放了k个king时有多少种方式，转移方程为 $dp[p][i][t] += dp[p-1][j][t-cnt[i]]$,cnt[i]表示i状态用了多少个king， 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;queue&gt; using namespace std; typedef long long ll;typedef pair&lt;int, int&gt; P; int n, k;ll dp[10][100][100];int tot;int st[100], cnt[100];int inlaw[100][100]; void init() &#123; tot = 0; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) &#123; if (i &amp; (i &gt;&gt; 1)) continue; else st[++tot] = i; for (int j = 0; j &lt; n; j++) &#123; if ((st[tot]&gt;&gt;j) &amp; 1) cnt[tot]++; &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; for (int j = 1; j &lt;= tot; j++) &#123; if (st[i]&amp;st[j] || st[i]&amp;(st[j]&lt;&lt;1) || st[i]&amp;(st[j]&gt;&gt;1)) inlaw[i][j] = 0; else inlaw[i][j] = 1; &#125; &#125;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;k); init(); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= tot; i++) dp[1][i][cnt[i]] = 1; for (int p = 2; p &lt;= n; p++) for (int i = 1; i &lt;= tot; i++) for (int t = cnt[i]; t &lt;= k; t++) for (int j = 1; j &lt;= tot; j++) if (inlaw[i][j]) dp[p][i][t] += dp[p-1][j][t-cnt[i]]; ll res = 0; for (int i = 1; i &lt;= tot; i++) res += dp[n][i][k]; printf(\"%lld\\n\", res); return 0;&#125;","path":"2018/04/18/bzoj1087scoi2005-e4-ba-92-e4-b8-8d-e4-be-b5-e7-8a-afking/","date":"04-18","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"dp","slug":"dp","permalink":"/tags/dp/"},{"name":"状压dp","slug":"状压dp","permalink":"/tags/状压dp/"}]},{"title":"BZOJ1041[HAOI2008]圆上的整点","text":"描述求一个给定的圆(x^2+y^2=r^2)，在圆周上有多少个点的坐标是整数。 输入只有一个正整数n,n&lt;=2000 000 000 输出整点个数 输入样例4 输出样例4 思路$x^2=(r-y)(r+y)$，记$d=gcd(r-y,r+y)$，令$A=a^2=\\frac{r+y}{d}$，令$B=b^2=\\frac{r-y}{d}$，$A+B=\\frac{2r}{d}$，A与B互质。 枚举d和A求多少B符合即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;# include &lt;cmath&gt;# include &lt;cstring&gt;# include &lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;ll ans = 0;ll n;ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a%b);&#125;ll solve(ll x) &#123; ll to = x/2; ll res = 0; for (ll i = 1; i * i &lt; to; i++) &#123; ll j = floor(sqrt(x-i*i) + 0.5); res += i\\*i + j\\*j == x &amp;&amp; gcd(i, j) == 1; &#125; return res;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%lld\", &amp;n); ans = 0; ll r = 2 * n; for (ll i = 1; i * i &lt;= r; i++) &#123; if (r % i == 0) &#123; ans += solve(i) + (i * i == r ? 0 : solve(r / i)); &#125; &#125; printf(\"%lld\\n\", 4*(ans+1)); return 0;&#125;","path":"2018/04/17/bzoj1041haoi2008-e5-9c-86-e4-b8-8a-e7-9a-84-e6-95-b4-e7-82-b9/","date":"04-17","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"数论","slug":"数论","permalink":"/tags/数论/"},{"name":"欧几里得算法","slug":"欧几里得算法","permalink":"/tags/欧几里得算法/"}]},{"title":"BZOJ1295[SCOI2009]最长距离","text":"描述windy有一块矩形土地，被分为 N*M 块 1*1 的小格子。 有的格子含有障碍物。 如果从格子A可以走到格子B，那么两个格子的距离就为两个格子中心的欧几里德距离。 如果从格子A不可以走到格子B，就没有距离。 如果格子X和格子Y有公共边，并且X和Y均不含有障碍物，就可以从X走到Y。 如果windy可以移走T块障碍物，求所有格子间的最大距离。 保证移走T块障碍物以后，至少有一个格子不含有障碍物。 输入输入文件maxlength.in第一行包含三个整数，N M T。 接下来有N行，每行一个长度为M的字符串，’0’表示空格子，’1’表示该格子含有障碍物。 输出输出文件maxlength.out包含一个浮点数，保留6位小数。 输入样例3 3 00010011104 3 00010010110003 3 1001001001 输出样例1.4142143.6055512.828427 思路用spfa计算任意两点间最少经过多少个障碍物，然后比较路径上障碍物数小于t的距离取最大值即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;queue&gt; using namespace std; typedef long long ll;typedef pair&lt;int, int&gt; P; const int MAX_N = 35;char s[MAX_N];int maze[MAX_N][MAX_N], vis[MAX_N][MAX_N];int dis[MAX_N][MAX_N];int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;int n, m, t;double ans; double distance(int x1, int y1, int x2, int y2) &#123; double x = abs(x1-x2); double y = abs(y1-y2); return sqrt(x*x+y*y);&#125; void spfa(int x, int y) &#123; memset(vis, 0, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[x][y] = maze[x][y]; queue&lt;P&gt; que; que.push(P(x, y)); vis[x][y] = true; while (!que.empty()) &#123; P nw = que.front(); que.pop(); vis[nw.first][nw.second] = false; for (int i = 0; i &lt; 4; i++) &#123; int tx = nw.first+dx[i], ty = nw.second+dy[i]; if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m) continue; if (dis[tx][ty] &gt; dis[nw.first][nw.second] + maze[tx][ty]) &#123; dis[tx][ty] = dis[nw.first][nw.second] + maze[tx][ty]; if (!vis[tx][ty]) &#123; vis[tx][ty] = true; que.push(P(tx, ty)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (dis[i][j] &lt;= t) &#123; ans = max(ans, distance(x, y, i, j)); &#125; &#125;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;t)) &#123; ans = 0; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", s); for (int j = 0; j &lt; m; j++) &#123; maze[i+1][j+1] = s[j] == '0' ? 0 : 1; &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; spfa(i, j); &#125; printf(\"%.6lf\\n\", ans); &#125; return 0;&#125;","path":"2018/04/16/bzoj1295scoi2009-e6-9c-80-e9-95-bf-e8-b7-9d-e7-a6-bb/","date":"04-16","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"spfa","slug":"spfa","permalink":"/tags/spfa/"},{"name":"暴力","slug":"暴力","permalink":"/tags/暴力/"}]},{"title":"BZOJ1084[SCOI2005]最大子矩阵","text":"描述这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。注意：选出的k个子矩阵 不能相互重叠。 输入第一行为n,m,k（1≤n≤100,1≤m≤2,1≤k≤10），接下来n行描述矩阵每行中的每个元素的分值(每个元素的 分值的绝对值不超过32767)。 输出只有一行为k个子矩阵分值之和最大为多少。 输入样例3 2 21 -32 3-2 3 输出样例9 思路m只能取1或2，分开讨论，m=1时就是在一维数组中取k个段使得和最大转移方程 $dp[i][k]=max(dp[i][k], dp[j][k-1]+sum[i]-sum[j])$m=2时转移方程 \\left\\{\\begin{matrix} dp2[i][j][t] = max(dp2[i][j][t], dp2[l][j][t-1]+sum1[i]-sum1[l]) & \\\\ dp2[i][j][t] = max(dp2[i][j][t], dp2[i][l][t-1]+sum2[j]-sum2[l]) & \\\\ dp2[i][j][t] = max(dp2[i][j][t], dp2[l][l][t-1]+sum1[i]-sum1[l]+sum2[j]-sum2[l]) & i==j \\end{matrix}\\right.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt; using namespace std; typedef long long ll; const int MAX_N = 110; int n, m, k, a, b;int dp1[MAX_N][11], dp2[MAX_N][MAX_N][11];int sum1[MAX_N], sum2[MAX_N]; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); if (m == 1) &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a); sum1[i] = sum1[i-1]+a; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int t = 1; t &lt;= k; t++) &#123; dp1[i][t] = dp1[i-1][t]; for (int j = 0; j &lt; i; j++) &#123; dp1[i][t] = max(dp1[i][t], dp1[j][t-1] + sum1[i] - sum1[j]); &#125; &#125; &#125; printf(\"%d\\n\", dp1[n][k]); &#125; else &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d %d\", &amp;a, &amp;b); sum1[i] = sum1[i-1] + a; sum2[i] = sum2[i-1] + b; &#125; for (int t = 1; t &lt;= k; t++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; dp2[i][j][t] = max(dp2[i-1][j][t], dp2[i][j-1][t]); for (int l = 0; l &lt; i; l++) dp2[i][j][t] = max(dp2[i][j][t], dp2[l][j][t-1]+sum1[i]-sum1[l]); for (int l = 0; l &lt; j; l++) dp2[i][j][t] = max(dp2[i][j][t], dp2[i][l][t-1]+sum2[j]-sum2[l]); if (i == j) &#123; for (int l = 0; l &lt; i; l++) &#123; dp2[i][j][t] = max(dp2[i][j][t], dp2[l][l][t-1]+sum1[i]-sum1[l]+sum2[j]-sum2[l]); &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\", dp2[n][n][k]); &#125; return 0;&#125;","path":"2018/04/16/bzoj1084scoi2005-e6-9c-80-e5-a4-a7-e5-ad-90-e7-9f-a9-e9-98-b5/","date":"04-16","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"dp","slug":"dp","permalink":"/tags/dp/"}]},{"title":"BZOJ1491[NOI2007]社交网络","text":"描述在社交网络（socialnetwork）的研究中，我们常常使用图论概念去解释一些社会现象。不妨看这样的一个问题。 在一个社交圈子里有n个人，人与人之间有不同程度的关系。我们将这个关系网络对应到一个n个结点的无向图上， 两个不同的人若互相认识，则在他们对应的结点之间连接一条无向边，并附上一个正数权值c，c越小，表示两个人 之间的关系越密切。我们可以用对应结点之间的最短路长度来衡量两个人s和t之间的关系密切程度，注意到最短路 径上的其他结点为s和t的联系提供了某种便利，即这些结点对于s和t之间的联系有一定的重要程度。我们可以通过 统计经过一个结点v的最短路径的数目来衡量该结点在社交网络中的重要程度。考虑到两个结点A和B之间可能会有 多条最短路径。我们修改重要程度的定义如下：令Cs,t表示从s到t的不同的最短路的数目，Cs,t(v)表示经过v从s 到t的最短路的数目；则定义 .png) 为结点v在社交网络中的重要程度。为了使I(v)和Cs,t(v)有意义，我们规定需要处理的社交网络都是连通的无向图 ，即任意两个结点之间都有一条有限长度的最短路径。现在给出这样一幅描述社交网络的加权无向图，请你求出每 一个结点的重要程度。 输入输入第一行有两个整数n和m，表示社交网络中结点和无向边的数目。在无向图中，我们将所有结点从1到n进行编号 。接下来m行，每行用三个整数a，b，c描述一条连接结点a和b，权值为c的无向边。注意任意两个结点之间最多有 一条无向边相连，无向图中也不会出现自环（即不存在一条无向边的两个端点是相同的结点）。n≤100；m≤4500 ，任意一条边的权值 c 是正整数，满足：1≤c≤1000。所有数据中保证给出的无向图连通，且任意两个结点之间 的最短路径数目不超过 10^10 输出输出包括n行，每行一个实数，精确到小数点后3位。第i行的实数表示结点i在社交网络中的重要程度。 输入样例4 41 2 12 3 13 4 14 1 1 输出样例1.0001.0001.0001.000 思路floyd计算最短路径时计算两点间的最短路径数量，最后暴力枚举。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt; using namespace std; typedef long long ll; const int MAX_N = 110;const int INF = 0x3f3f3f3f; int dp[MAX_N][MAX_N];double f[MAX_N][MAX_N];int n, m; void floyd() &#123; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (dp[i][j] &gt; dp[i][k] + dp[k][j]) dp[i][j]=dp[i][k]+dp[k][j], f[i][j] = 0; if (dp[i][j]==dp[i][k]+dp[k][j]) f[i][j] += f[i][k]*f[k][j]; &#125; &#125; &#125;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123;if(i==j) dp[i][j] = 0; else dp[i][j] = INF; &#125; for (int i = 0; i &lt; m; i++) &#123; int x, y, z; scanf(\"%d %d %d\", &amp;x, &amp;y, &amp;z); dp[x][y] = dp[y][x] = z; f[x][y] = f[y][x] = 1; &#125; floyd(); for (int k = 1; k &lt;= n; k++) &#123; double ans = 0.0; for (int i = 1; i &lt;= n; i++) &#123; if (i != k) for (int j = 1; j &lt;= n; j++) &#123; if (j != k &amp;&amp; dp[i][j] == dp[i][k] + dp[k][j]) ans += 1.0*f[i][k]*f[k][j] / f[i][j]; &#125; &#125; printf(\"%.3lf\\n\", ans); &#125; return 0;&#125;","path":"2018/04/15/bzoj1491noi2007-e7-a4-be-e4-ba-a4-e7-bd-91-e7-bb-9c/","date":"04-15","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"dp","slug":"dp","permalink":"/tags/dp/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"暴力","slug":"暴力","permalink":"/tags/暴力/"},{"name":"floyd","slug":"floyd","permalink":"/tags/floyd/"},{"name":"枚举","slug":"枚举","permalink":"/tags/枚举/"}]},{"title":"BZOJ1208[HNOI2004]宠物收养所","text":"描述最近，阿Q开了一间宠物收养所。收养所提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。每个领养者都希望领养到自己满意的宠物，阿Q根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值a（a是一个正整数，a&lt;2^31），而他也给每个处在收养所的宠物一个特点值。这样他就能够很方便的处理整个领养宠物的过程了，宠物收养所总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少。 1． 被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为a，那么它将会领养一只目前未被领养的宠物中特点值最接近a的一只宠物。（任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的）如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为a-b和a+b，那么领养者将会领养特点值为a-b的那只宠物。 2． 收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为a，存在两个领养者他们希望领养宠物的特点值分别为a-b和a+b，那么特点值为a-b的那个领养者将成功领养该宠物。 一个领养者领养了一个特点值为a的宠物，而它本身希望领养的宠物的特点值为b，那么这个领养者的不满意程度为abs(a-b)。【任务描述】你得到了一年当中，领养者和被收养宠物到来收养所的情况，希望你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。 输入第一行为一个正整数n，n&lt;=80000，表示一年当中来到收养所的宠物和领养者的总数。接下来的n行，按到来时间的先后顺序描述了一年当中来到收养所的宠物和领养者的情况。每行有两个正整数a, b，其中a=0表示宠物，a=1表示领养者，b表示宠物的特点值或是领养者希望领养宠物的特点值。（同一时间呆在收养所中的，要么全是宠物，要么全是领养者，这些宠物和领养者的个数不会超过10000个） 输出仅有一个正整数，表示一年当中所有收养了宠物的领养者的不满意程度的总和mod 1000000以后的结果。 输入样例50 20 41 31 21 5 输出样例3 思路用标记标记一下现在是商店里是宠物还是人，数值用splay维护一下就好了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std; typedef long long ll; const int MAX_N = 80010;const int INF = 1000000000; struct Node &#123; Node* ch[2], *p; int val, size; Node() &#123;size = 0;&#125; bool d() &#123; return this == p -&gt; ch[1]; &#125; void setc(Node* c, int d) &#123; ch[d] = c; c-&gt;p = this; &#125; void upd() &#123; size = ch[0]-&gt;size + ch[1]-&gt;size + 1; &#125;&#125; Tnull, *null = &amp;Tnull;Node mem[MAX_N], *C = mem; Node* make(int v) &#123; C-&gt;ch[0] = C-&gt;ch[1] = null; C-&gt;val = v; C-&gt;size = 1; return C++;&#125; Node* root = null; void rot(Node* t) &#123; Node* p = t-&gt;p; int d = t-&gt;d(); p-&gt;p-&gt;setc(t, p-&gt;d()); p-&gt;setc(t-&gt;ch[!d], d); t-&gt;setc(p, !d); p-&gt;upd(); if (p == root) root = t;&#125; void splay(Node* t, Node* f = null) &#123; while (t-&gt;p != f) &#123; if (t-&gt;p-&gt;p == f) rot(t); else t-&gt;d() == (t-&gt;p-&gt;d()) ? (rot(t-&gt;p), rot(t)) : (rot(t), rot(t)); &#125; t-&gt;upd();&#125; void ins(int v) &#123; if (root == null) &#123; root = make(v); root-&gt;p = null; return ; &#125; Node* p = root; Node* k = null; Node* nw = null; while (p != null &amp;&amp; p-&gt;val != v) &#123; k = p; p = p-&gt;ch[v&gt;p-&gt;val]; &#125; if (p == null) &#123; k-&gt;setc(nw = make(v), v&gt;k-&gt;val); &#125; else return ; splay(nw);&#125; void print(Node* p) &#123; if (p == null) return ; print(p-&gt;ch[0]); cout &lt;&lt; p-&gt;val &lt;&lt; endl; print(p-&gt;ch[1]);&#125; void debug() &#123; Node* p = root; print(root);&#125; void ran(int v) &#123; if (root == null) return ; Node* p = root; while (p-&gt;ch[v&gt;p-&gt;val] != null &amp;&amp; p-&gt;val != v) p = p-&gt;ch[v&gt;p-&gt;val]; splay(p);&#125; Node* prev(int v) &#123; ran(v); if (root-&gt;val&lt;=v) return root; Node* p = root-&gt;ch[0]; while (p-&gt;ch[1] != null) p = p-&gt;ch[1]; return p;&#125; Node* succ(int v) &#123; ran(v); if (root-&gt;val&gt;=v) return root; Node* p = root-&gt;ch[1]; while (p-&gt;ch[0] != null) p = p-&gt;ch[0]; return p;&#125; void erase(Node* t) &#123; ran(t-&gt;val); Node* k = null; if (t-&gt;ch[0] == null || t-&gt;ch[1] == null) &#123; root = t-&gt;ch[0] == null ? t-&gt;ch[1] : t-&gt;ch[0]; root -&gt; p = null; return ; &#125; else &#123; k = t-&gt;ch[1]; while (k-&gt;ch[0] != null) k = k-&gt;ch[0]; k-&gt;size += root-&gt;ch[0]-&gt;size; root-&gt;ch[0]-&gt;p = k; k-&gt;ch[0] = root-&gt;ch[0]; root = root-&gt;ch[1]; root-&gt;p = null; splay(k); &#125;&#125; int n, t, v, nw; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;n); int ans = 0; ins(-INF); ins(INF); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d %d\", &amp;t, &amp;v); if (root-&gt;size == 2) &#123; nw = t; &#125; else if (nw != t) &#123; Node* lo = prev(v); Node* hi = succ(v); Node* p = null; if (lo-&gt;val == -INF) p = hi; else if (hi-&gt;val == INF) p = lo; else p = ((v - lo-&gt;val) &lt;= (hi-&gt;val - v)) ? lo : hi; ans += abs(p-&gt;val - v); ans %= 1000000; erase(p); &#125; if (nw == t) ins(v); &#125; printf(\"%d\\n\", ans); return 0;&#125;","path":"2018/04/15/bzoj1208hnoi2004-e5-ae-a0-e7-89-a9-e6-94-b6-e5-85-bb-e6-89-80/","date":"04-15","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"splay","slug":"splay","permalink":"/tags/splay/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}]},{"title":"BZOJ1588[HNOI2002]营业额统计","text":"描述营业额统计 Tiger最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。 Tiger拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况： 该天的最小波动值 当最小波动值越大时，就说明营业情况越不稳定。 而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助Tiger来计算这一个值。 第一天的最小波动值为第一天的营业额。  输入输出要求 输入第一行为正整数 ，表示该公司从成立一直到现在的天数，接下来的n行每行有一个整数(有可能有负数) ，表示第i 天公司的营业额。 天数n&lt;=32767, 每天的营业额ai &lt;= 1,000,000。 最后结果T&lt;=2^31 输出输出文件仅有一个正整数，即Sigma(每天最小的波动值) 。结果小于2^31 。 输入样例6512546 输出样例12 思路用splay维护一下就行，该题是模版题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;# include &lt;cmath&gt;using namespace std;typedef long long ll;const int MAX_N = 40000;const int INF = 1000001;struct Node &#123; Node* ch[2], *p; int val; bool d() &#123; return this == p -&gt; ch[1]; &#125; void setc(Node* c, int d) &#123; ch[d] = c; c-&gt;p = this; &#125;&#125; Tnull, *null = &amp;Tnull;Node mem[MAX_N], *C = mem;Node* make(int v) &#123; C-&gt;ch[0] = C-&gt;ch[1] = null; C-&gt;val = v; return C++;&#125;Node* root = null;void rot(Node* t) &#123; Node* p = t-&gt;p; int d = t-&gt;d(); p-&gt;p-&gt;setc(t, p-&gt;d()); p-&gt;setc(t-&gt;ch[!d], d); t-&gt;setc(p, !d); if (p == root) root = t;&#125;void splay(Node* t, Node* f = null) &#123; while (t-&gt;p != f) &#123; if (t-&gt;p-&gt;p == f) rot(t); else t-&gt;d() == (t-&gt;p-&gt;d()) ? (rot(t-&gt;p), rot(t)) : (rot(t), rot(t)); &#125;&#125;void ins(int v) &#123; if (root == null) &#123; root = make(v); root-&gt;p = null; return ; &#125; Node* p = root; Node* k = null; Node* nw = null; while (p != null &amp;&amp; p-&gt;val != v) &#123; k = p; p = p-&gt;ch[v&gt;p-&gt;val]; &#125; if (p == null) &#123; k-&gt;setc(nw = make(v), v&gt;k-&gt;val); &#125; else return ; splay(nw);&#125;void ran(int v) &#123; if (root == null) return ; Node* p = root; while (p-&gt;ch[v&gt;p-&gt;val] != null &amp;&amp; p-&gt;val != v) p = p-&gt;ch[v&gt;p-&gt;val]; splay(p);&#125;Node* prev(int v) &#123; ran(v); if (root-&gt;val&lt;=v) return root; Node* p = root-&gt;ch[0]; while (p-&gt;ch[1] != null) p = p-&gt;ch[1]; return p;&#125;Node* succ(int v) &#123; ran(v); if (root-&gt;val&gt;=v) return root; Node* p = root-&gt;ch[1]; while (p-&gt;ch[0] != null) p = p-&gt;ch[0]; return p;&#125;int n, m;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;n); ins(INF); ins(-INF); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;m); if (i == 0) &#123; ins(m); ans += m; continue; &#125; int lo = prev(m) -&gt; val; int hi = succ(m) -&gt; val; if (lo == -INF) ans += abs(hi - m); else if (hi == INF) ans += abs(m - lo); else ans += min(abs(hi-m), abs(m-lo)); ins(m); &#125; printf(\"%d\\n\", ans); return 0;&#125;","path":"2018/04/15/1588-hnoi2002-e8-90-a5-e4-b8-9a-e9-a2-9d-e7-bb-9f-e8-ae-a1/","date":"04-15","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"splay","slug":"splay","permalink":"/tags/splay/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}]},{"title":"BZOJ1051[HAOI2006]受欢迎的牛","text":"描述每一头牛的愿望就是变成一头最受欢迎的牛。现在有N头牛，给你M对整数(A,B)，表示牛A认为牛B受欢迎。 这 种关系是具有传递性的，如果A认为B受欢迎，B认为C受欢迎，那么牛A也认为牛C受欢迎。你的任务是求出有多少头 牛被所有的牛认为是受欢迎的。 输入第一行两个数N,M。 接下来M行，每行两个数A,B，意思是A认为B是受欢迎的（给出的信息有可能重复，即有可 能出现多个A,B） 输出一个数，即有多少头牛被所有的牛认为是受欢迎的。 输入样例3 31 22 12 3 输出样例1 思路先tarjan缩点，看是不是只有一个出度为0的点，是则该点原本对应的所有点都是受欢迎的牛，若不是则数量为0。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt; using namespace std; typedef long long ll; struct Data &#123; int to, nxt;&#125;e[50010], d[50010];int head[10010], h[10010], q[10010], dfn[10010], low[10010], belong[10010], hav[10010];int n, m, tot = 0, cnt = 0, top = 0, scc = 0, ans = 0;bool vis[10010], inq[10010]; void dfs(int x) &#123; int now; cnt++; dfn[x] = low[x] = cnt; vis[x] = inq[x] = true; q[++top] = x; int c = head[x]; while (c) &#123; if (!vis[e[c].to]) &#123; dfs(e[c].to); low[x] = min(low[x], low[e[c].to]); &#125; else if (inq[e[c].to]) &#123; low[x] = min(low[x], dfn[e[c].to]); &#125; c = e[c].nxt; &#125; if (dfn[x] == low[x]) &#123; scc++; while (now != x) &#123; now = q[top--]; inq[now] = false; belong[now] = scc; ++hav[scc]; &#125; &#125;&#125; void rebuild() &#123; tot = 0; for (int i = 1; i &lt;= n; i++) &#123; int c = head[i];; while (c) &#123; if (belong[i] != belong[e[c].to]) &#123; d[++tot].to = belong[e[c].to]; d[tot].nxt = h[belong[i]]; h[belong[i]] = tot; &#125; c = e[c].nxt; &#125; &#125;&#125; void tarjan() &#123; for (int i = 1; i &lt;= n; i++) if (!vis[i]) dfs(i); rebuild();&#125; void work() &#123; ans = 0; for (int i = 1; i &lt;= scc; i++) &#123; if (!h[i]) &#123; if (ans) &#123; ans = 0; return ; &#125; else &#123; ans = hav[i]; &#125; &#125; &#125;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(\"%d %d\", &amp;x, &amp;y); e[i].to = y; e[i].nxt = head[x]; head[x] = i; &#125; tarjan(); work(); printf(\"%d\\n\", ans); return 0;&#125;","path":"2018/04/13/haoi2006-e5-8f-97-e6-ac-a2-e8-bf-8e-e7-9a-84-e7-89-9b/","date":"04-13","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"tarjan","slug":"tarjan","permalink":"/tags/tarjan/"},{"name":"缩点","slug":"缩点","permalink":"/tags/缩点/"}]},{"title":"BZOJ1202[HNOI2005]狡猾的商人","text":"描述刁姹接到一个任务，为税务部门调查一位商人的账本，看看账本是不是伪造的。账本上记录了n个月以来的收入情况，其中第i 个月的收入额为Ai(i=1,2,3…n-1,n)， 。当 Ai大于0时表示这个月盈利Ai 元，当 Ai小于0时表示这个月亏损Ai 元。所谓一段时间内的总收入，就是这段时间内每个月的收入额的总和。 刁姹的任务是秘密进行的，为了调查商人的账本，她只好跑到商人那里打工。她趁商人不在时去偷看账本，可是她无法将账本偷出来，每次偷看账本时她都只能看某段时间内账本上记录的收入情况，并且她只能记住这段时间内的总收入。 现在，刁姹总共偷看了m次账本，当然也就记住了m段时间内的总收入，你的任务是根据记住的这些信息来判断账本是不是假的。 输入第一行为一个正整数w，其中w &lt; 100，表示有w组数据，即w个账本，需要你判断。每组数据的第一行为两个正整数n和m，其中n &lt; 100，m &lt; 1000，分别表示对应的账本记录了多少个月的收入情况以及偷看了多少次账本。接下来的m行表示刁姹偷看m次账本后记住的m条信息，每条信息占一行，有三个整数s，t和v，表示从第s个月到第t个月（包含第t个月）的总收入为v，这里假设s总是小于等于t。 输出包含w行,每行是true或false,其中第i行为true当且仅当第i组数据，即第i个账本不是假的；第i行为false当且仅当第i组数据，即第i个账本是假的。 输入样例23 31 2 101 3 -53 3 -155 31 5 1003 5 501 2 51 输出样例truefalse 思路用带权并查集维护天数信息，权ran[i]表示从根节点到第i天的收入，每次判断两天是否在同一集合，在同一集合就看收入是否正确，不是就合并。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt; using namespace std; typedef long long ll; const int MAX_N = 110; int T;int n, m;int par[MAX_N], ran[MAX_N];bool flag; void init(int n) &#123; for (int i = 0; i &lt;= n; i++) &#123; par[i] = i; ran[i] = 0; &#125;&#125; int find(int x) &#123; if (x == par[x]) return x; int t = find(par[x]); ran[x] = ran[par[x]] + ran[x]; par[x] = t; return par[x];&#125; void work(int u, int v, int c) &#123; int pu = find(u), pv = find(v); if (pu == pv) &#123; if (ran[v] - ran[u] != c) flag = 1; &#125; else &#123; int x = c + ran[u] - ran[v]; par[pv] = pu; ran[pv] = x; &#125;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;T); while (T--) &#123; flag = 0; scanf(\"%d %d\", &amp;n, &amp;m); init(n); int u, v, c; for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;c); work(u-1, v, c); &#125; if (flag) printf(\"false\\n\"); else printf(\"true\\n\"); &#125; return 0;&#125;","path":"2018/04/13/hnoi2005-e7-8b-a1-e7-8c-be-e7-9a-84-e5-95-86-e4-ba-ba/","date":"04-13","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"/tags/并查集/"},{"name":"带权并查集","slug":"带权并查集","permalink":"/tags/带权并查集/"}]},{"title":"BZOJ1059[ZJOI2007]矩阵游戏","text":"描述小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏——矩阵游戏。矩阵游戏在一个N *N黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：行交换操作：选择 矩阵的任意两行，交换这两行（即交换对应格子的颜色）列交换操作：选择矩阵的任意行列，交换这两列（即交换 对应格子的颜色）游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑 色。对于某些关卡，小Q百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！！于是小Q决定写一个程 序来判断这些关卡是否有解。 输入第一行包含一个整数T，表示数据的组数。接下来包含T组数据，每组数据第一行为一个整数N，表示方阵的大 小；接下来N行为一个N*N的01矩阵（0表示白色，1表示黑色）。 输出输出文件应包含T行。对于每一组数据，如果该关卡有解，输出一行Yes；否则输出一行No。 输入样例220 00 130 0 10 1 01 0 0 输出样例NoYes 思路无论是行交换还是列交换都不会改变同一行，同一列的黑点位置，所有要让题目有解只要每行每列都有黑点即可，题目就转换成列行列的二分图匹配问题，直接用匈牙利算法即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt; using namespace std; typedef long long ll; const int MAX_N = 1001; int T, n;int mark[MAX_N][MAX_N];int used[MAX_N], lk[MAX_N]; bool find(int x) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (mark[x][i] &amp;&amp; !used[i]) &#123; used[i] = 1; if (lk[i] == 0 || find(lk[i])) &#123; lk[i] = x; return true; &#125; &#125; &#125; return false;&#125; void solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; memset(used, 0, sizeof(used)); if (!find(i)) &#123; printf(\"No\\n\"); return ; &#125; &#125; printf(\"Yes\\n\"); return ;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;T); while (T--) &#123; memset(mark, 0, sizeof(mark)); memset(lk, 0, sizeof(lk)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; scanf(\"%d\", &amp;mark[i][j]); &#125; &#125; solve(); &#125; return 0;&#125;","path":"2018/04/13/zjoi2007-e7-9f-a9-e9-98-b5-e6-b8-b8-e6-88-8f/","date":"04-13","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"/tags/二分图匹配/"},{"name":"匈牙利算法","slug":"匈牙利算法","permalink":"/tags/匈牙利算法/"}]},{"title":"BZOJ1191[HNOI2006]超级英雄Hero","text":"描述现在电视台有一种节目叫做超级英雄,大概的流程就是每位选手到台上回答主持人的几个问题,然后根据回答问题的 多少获得不同数目的奖品或奖金。主持人问题准备了若干道题目，只有当选手正确回答一道题后，才能进入下一题 ，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总提供给选手几个“锦囊妙计”，比如求助现场 观众，或者去掉若干个错误答案（选择题）等等。这里，我们把规则稍微改变一下。假设主持人总共有m道题，选 手有n种不同的“锦囊妙计”。主持人规定，每道题都可以从两种“锦囊妙计”中选择一种，而每种“锦囊妙计” 只能用一次。我们又假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。现在我来到了 节目现场，可是我实在是太笨了，以至于一道题也不会做，每道题只好借助使用“锦囊妙计”来通过。如果我事先 就知道了每道题能够使用哪两种“锦囊妙计”，那么你能告诉我怎样选择才能通过最多的题数吗？ 输入输入文件的一行是两个正整数n和m(0 &lt; n &lt;1001,0 &lt; m &lt; 1001)表示总共有n中“锦囊妙计”，编号为0~n-1，总共有m个问题。 以下的m行，每行两个数，分别表示第m个问题可以使用的“锦囊妙计”的编号。 注意，每种编号的“锦囊妙计”只能使用一次，同一个问题的两个“锦囊妙计”可能一样。 输出第一行为最多能通过的题数p 输入样例5 63 22 00 30 43 23 2 输出样例4 思路本质上就是一个二分图最大匹配，匈牙利算法暴力即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt; using namespace std; typedef long long ll; const int MAX_N = 1001; int n, m;int mark[MAX_N][MAX_N];int used[MAX_N], lk[MAX_N]; bool find(int x) &#123; for (int i = 0; i &lt; n; i++) &#123; if (mark[x][i] &amp;&amp; !used[i]) &#123; used[i] = 1; if (lk[i] == 0 || find(lk[i])) &#123; lk[i] = x; return true; &#125; &#125; &#125; return false;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); memset(mark, 0, sizeof(mark)); memset(lk, 0, sizeof(lk)); memset(used, 0, sizeof(used)); scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int a, b; scanf(\"%d %d\", &amp;a, &amp;b); mark[i][a] = 1; mark[i][b] = 1; &#125; int ans = 0; for (int i = 1; i &lt;= m; i++) &#123; memset(used, 0, sizeof(used)); if (find(i)) ans++; else break; &#125; printf(\"%d\\n\", ans); return 0;&#125;","path":"2018/04/13/hnoi2006-e8-b6-85-e7-ba-a7-e8-8b-b1-e9-9b-84hero/","date":"04-13","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"},{"name":"暴力","slug":"暴力","permalink":"/tags/暴力/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"/tags/二分图匹配/"},{"name":"匈牙利算法","slug":"匈牙利算法","permalink":"/tags/匈牙利算法/"}]},{"title":"BZOJ1270[BJWc2008]雷涛的小猫","text":"描述雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫(当然，这样的行为是违反学生宿舍管理条例的)。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。 可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆… 在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有N棵。并且这N棵柿子树每棵的高度都是H。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。 小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳1单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降Delta单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。 雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。 输入输入文件的第一行有三个以空格分隔的整数，分别代表N, H, Delta 接下来的N行，每行第一个整数为Ni，代表第i棵树上的柿子数量。 接下来是Ni个整数，每个整数Tij代表第i棵柿子树的Tij高度上长有一个柿子。 输出输出仅包含一个整数，即小猫最多吃到的柿子数。 样例输入3 10 23 1 4 106 3 5 9 7 8 95 4 5 3 6 9 样例输出8 提示1 ≤ N, H ≤ 2000 0 ≤ Ni ≤ 5000 1 ≤ Delta ≤ N, 1 ≤ Tij ≤ H 输入文件大小不大于40960KB 思路定义$dp[i]$为当前高度第i课数时吃到的最多柿子数，用$mx[h]$记录高度为h时吃到的最多柿子数，转移方程就是$dp[j]=max(dp[j], mx[i+D])+orign[j][i]$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cmath&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;queue&gt;# include &lt;map&gt;using namespace std;typedef long long ll;const int MAX_N = 2010;int N, H, D;int dp[MAX_N], mx[MAX_N];int orign[MAX_N][MAX_N];int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); memset(orign, 0, sizeof(orign)); scanf(\"%d %d %d\", &amp;N, &amp;H, &amp;D); int k; for (int i = 1; i &lt;= N; i++) &#123; scanf(\"%d\", &amp;k); for (int j = 0; j &lt; k; j++) &#123; int tmp; scanf(\"%d\", &amp;tmp); orign[i][tmp]++; &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; dp[i] = orign[i][H]; mx[H] = max(mx[H], dp[i]); &#125; for (int i = H-1; i &gt;= 0; i--) &#123; for (int j = 1; j &lt;= N; j++) &#123; if (i+D &gt; H) dp[j] = dp[j] + orign[j][i]; else &#123; dp[j] = max(dp[j], mx[i+D]) + orign[j][i]; &#125; mx[i] = max(mx[i], dp[j]); &#125; &#125; printf(\"%d\\n\", mx[0]); return 0;&#125;","path":"2018/04/12/bjwc2008-e9-9b-b7-e6-b6-9b-e7-9a-84-e5-b0-8f-e7-8c-ab/","date":"04-12","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"dp","slug":"dp","permalink":"/tags/dp/"}]},{"title":"BZOJ1303[CQOI2009]中位数图","text":"描述给出1~n的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。中位数是指把所有元素从小到大排列后，位于中间的数。 输入第一行为两个正整数n和b ，第二行为1~n 的排列。 输出输出一个整数，即中位数为b的连续子序列个数。 样例输入7 45 7 2 4 3 1 6 样例输出4 HINT第三个样例解释：{4}, {7,2,4}, {5,7,2,4,3}和{5,7,2,4,3,1,6} N&lt;=100000 思路把数列中小于b的数计作-1，大于b的数计作1，等于b的数计作0。分别统计b左边的所有连续区间的和以及右边的所有连续区间的和，为了防止出现负数无法处理的情况可以统一把区间和加上一个n，只要满足左右区间和相加为2*n的对都是满足的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt; using namespace std; const int MAX_N = 100100;int n, b, tmp, p;int t[MAX_N];int l[MAX_N&lt;&lt;1], r[MAX_N&lt;&lt;1], prefix[MAX_N]; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;b); prefix[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;tmp); if (tmp &gt; b) t[i] = 1; else if (tmp &lt; b) t[i] = -1; else &#123; p = i; t[i] = 0; &#125; prefix[i] = prefix[i-1] + t[i]; &#125; for (int i = 1; i &lt; p; i++) &#123; l[prefix[i]+n]++; &#125; for (int i = p; i &lt;= n; i++) &#123; r[prefix[i]+n]++; &#125; l[n]++; int ans = 0; for (int i = 0; i &lt;= 2 * n; i++) &#123; ans += l[i] * r[i]; &#125; printf(\"%d\\n\", ans); return 0;&#125;","path":"2018/04/12/bzoj1303-e4-b8-ad-e4-bd-8d-e6-95-b0-e5-9b-be/","date":"04-12","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"前缀和","slug":"前缀和","permalink":"/tags/前缀和/"},{"name":"思维","slug":"思维","permalink":"/tags/思维/"}]},{"title":"BZOJ1192[HNOI]鬼谷子的钱袋","text":"描述鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。但是，他的行程安排得很满，他他已经买好了去邯郸的长途马车标，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？ 输入包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1≤m ≤1000000000。 输出只有一个整数h，表示所用钱袋个数 样例输入3 样例输出2 思路其实就是看输入的m二进制表示有多少位 代码12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; typedef long long ll; const int MAX_N = 100; int len;ll num;ll a[MAX_N]; void init() &#123; a[1] = 1; a[2] = 2; len = 2; while (a[len] &lt;= 1000000000) &#123; len++; a[len] = 2 * a[len-1]; &#125;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); init(); scanf(\"%lld\", &amp;num); int p = lower_bound(a+1, a+1+len, num) - a; if (a[p] == num) printf(\"%d\\n\", p); else printf(\"%d\\n\", p-1); return 0;&#125;","path":"2018/04/12/bzoj-1192-e9-ac-bc-e8-b0-b7-e5-ad-90-e7-9a-84-e9-92-b1-e8-a2-8b/","date":"04-12","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"二进制","slug":"二进制","permalink":"/tags/二进制/"}]},{"title":"BZOJ1002[FJOI]轮状病毒","text":"描述轮状病毒有很多变种，所有轮状病毒的变种都是从一个轮状基产生的。一个N轮状基由圆环上N个不同的基原子 和圆心处一个核原子构成的，2个原子之间的边表示这2个原子之间的信息通道。如下图所示 .png) N轮状病毒的产生规律是在一个N轮状基中删去若干条边，使得各原子之间有唯一的信息通道，例如共有16个不 同的3轮状病毒，如下图所示 .png) 现给定n(N&lt;=100)，编程计算有多少个不同的n轮状病毒 输入第一行有1个正整数n 输出计算出的不同的n轮状病毒数输出 样例输入3 样例输出16 思路找规律可以推出$f[n]=3*f[n-1]-f[n-2]+2​$，数字比较大要模拟高精度，不过加减简单而且一定是正数所以比较简单，直接用python就更简单了。 代码（c++）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cmath&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;queue&gt;using namespace std;typedef long long ll;struct Num &#123; int a[110], len;&#125;f[110];Num mul(Num num, int m) &#123; for (int i = 1; i &lt;= num.len; i++) &#123; num.a[i] *= m; &#125; for (int i = 1; i &lt;= num.len; i++) &#123; num.a[i+1] += num.a[i] / 10; num.a[i] %= 10; &#125; if (num.a[num.len+1] &gt; 0) &#123; num.len++; while (num.a[num.len] &gt; 9) &#123; num.a[num.len+1] += num.a[num.len] / 10; num.a[num.len] %= 10; num.len++; &#125; &#125; // if (num.a\\[num.len+1\\] &gt; 0) num.len++; return num;&#125;Num add(Num num, int b) &#123; num.a[1] += 2; for (int i = 1; i &lt;= num.len; i++) &#123; num.a[i+1] += num.a[i] / 10; num.a[i] %= 10; &#125; if (num.a[num.len+1] &gt; 0) &#123; num.len++; while (num.a[num.len] &gt; 9) &#123; num.a[num.len+1] += num.a[num.len] / 10; num.a[num.len] %= 10; num.len++; &#125; &#125; return num;&#125;Num sub(Num num, Num n) &#123; for (int i = 1; i &lt;= n.len; i++) &#123; if (num.a[i] &lt; n.a[i]) &#123; num.a[i] += 10; num.a[i+1] -= 1; int t = i+1; while (num.a[t] &lt; 0) &#123; num.a[t] = 9; num.a[t+1]--; t = t+1; &#125; &#125; num.a[i] -= n.a[i]; &#125; if (num.a[num.len] == 0) num.len--; return num;&#125;void out(Num num) &#123; for (int i = num.len; i &gt;= 1; i--) &#123; cout &lt;&lt; num.a[i]; &#125; cout &lt;&lt; endl;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); int n; cin &gt;&gt; n; f[1].a[1] = 1; f[2].a[1] = 5; f[1].len = f[2].len = 1; for (int i = 3; i &lt;= n; i++) &#123; f[i] = add(sub(mul(f[i-1], 3), f[i-2]), 2); &#125; out(f[n]); return 0;&#125; 代码（python）12345678910111213141516n = (int)(input())a = 1b = 5if n == 1: print(a)elif n == 2: print(b)else: ans = 0 for i in range(n-2): ans = 3 * b - a + 2 c = b b = ans a = c print(ans)","path":"2018/04/12/bzoj1002-e8-bd-ae-e7-8a-b6-e7-97-85-e6-af-92/","date":"04-12","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"递推","slug":"递推","permalink":"/tags/递推/"},{"name":"高精度","slug":"高精度","permalink":"/tags/高精度/"}]},{"title":"BZOJ1003[ZJOI]物流运输","text":"描述物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要n天才能运完。货物运输过程中一般要转 停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种 因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是 修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个n天的运输计划，使得总成本 尽可能地小。 输入第一行是四个整数n（1&lt;=n&lt;=100）、m（1&lt;=m&lt;=20）、K和e。n表示货物运输所需天数，m表示码头总数，K表示 每次修改运输路线所需成本。接下来e行每行是一条航线描述，包括了三个整数，依次表示航线连接的两个码头编 号以及航线长度（&gt;0）。其中码头A编号为1，码头B编号为m。单位长度的运输费用为1。航线是双向的。再接下来 一行是一个整数d，后面的d行每行是三个整数P（ 1 &lt; P &lt; m）、a、b（1&lt; = a &lt; = b &lt; = n）。表示编号为P的码 头从第a天到第b天无法装卸货物（含头尾）。同一个码头有可能在多个时间段内不可用。但任何时间都存在至少一 条从码头A到码头B的运输路线。 输出包括了一个整数表示最小的总成本。总成本=n天运输路线长度之和+K*改变运输路线的次数。 样例输入5 5 10 81 2 11 3 31 4 22 3 22 4 43 4 13 5 24 5 242 2 33 1 13 3 34 4 5 样例输出32 HINT前三天走1-4-5，后两天走1-3-5，这样总成本为(2+2)*3+(3+2)*2+10=32 思路令$t[i][j]$为从第i天到第j天都能走的最短路长度，可以用spfa得到，令$f[i]$为从第1天到第i天的最小成本，可以得到方程$f[i]=min(f[i], f[j]+k+t[j+1][i]*(i-j))$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cmath&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;queue&gt;using namespace std;typedef long long ll;const ll INF = 0x3f3f3f3f;struct Data &#123; int to, nxt; ll w;&#125;e[810];int ne = 0, head[21];ll t[101][101], f[101];int flag[21][101];int n, m, k, q;void addEdge(int u, int v, ll w) &#123; ne++; e[ne].to = v; e[ne].w = w; e[ne].nxt = head[u]; head[u] = ne;&#125;ll spfa(int a, int b) &#123; int block[21]; memset(block, 0, sizeof(block)); for (int i = 1; i &lt;= m; i++) &#123; for (int j = a; j &lt;= b; j++) &#123; if(flag[i][j]) block[i] = 1; &#125; &#125; int inq[21]; ll dis[21]; memset(inq, 0, sizeof(inq)); for (int i = 1; i &lt;= m; i++) dis[i] = INF; queue&lt;int&gt; que; que.push(1); inq[1] = 1; dis[1] = 0; while (!que.empty()) &#123; int t = que.front(); que.pop(); int p = head[t]; while (p) &#123; if (block[e[p].to] == 0 &amp;&amp; dis[e[p].to] &gt; dis[t] + e[p].w) &#123; dis[e[p].to] = dis[t] + e[p].w; if (!inq[e[p].to]) &#123; que.push(e[p].to); inq[e[p].to] = 1; &#125; &#125; p = e[p].nxt; &#125; inq[t] = 0; &#125; return dis[m];&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); memset(flag, 0, sizeof(flag)); ne = 0; scanf(\"%d %d %d %d\", &amp;n, &amp;m, &amp;k, &amp;q); for (int i = 0; i &lt; q; i++) &#123; int x, y; ll w; scanf(\"%d %d %lld\", &amp;x, &amp;y, &amp;w); addEdge(x, y, w); addEdge(y, x, w); &#125; int d = 0; scanf(\"%d\", &amp;d); for (int i = 0; i &lt; d; i++) &#123; int p, l, r; scanf(\"%d %d %d\", &amp;p, &amp;l, &amp;r); for (int j = l; j &lt;= r; j++) flag[p][j] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; t[i][j] = spfa(i, j); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; f[i] = t[1][i] * i; for (int j = 1; j &lt; i; j++) &#123; f[i] = min(f[i], f[j] + k + t[j+1][i] * (i - j)); &#125; &#125; printf(\"%lld\\n\", f[n]); return 0;&#125;","path":"2018/04/12/bzoj1003-e7-89-a9-e6-b5-81-e8-bf-90-e8-be-93/","date":"04-12","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"spfa","slug":"spfa","permalink":"/tags/spfa/"},{"name":"区间dp","slug":"区间dp","permalink":"/tags/区间dp/"},{"name":"图论","slug":"图论","permalink":"/tags/图论/"}]},{"title":"BZOJ1601[Usaco2008] Oct 灌水","text":"描述Farmer John已经决定把水灌到他的n(1&lt;=n&lt;=300)块农田，农田被数字1到n标记。把一块土地进行灌水有两种方法，从其他农田饮水，或者这块土地建造水库。 建造一个水库需要花费wi(1&lt;=wi&lt;=100000),连接两块土地需要花费Pij(1&lt;=pij&lt;=100000,pij=pji,pii=0). 计算Farmer John所需的最少代价。 输入第一行：一个数n 第二行到第n+1行：第i+1行含有一个数wi 第n+2行到第2n+1行：第n+1+i行有n个被空格分开的数，第j个数代表pij。 输出第一行：一个单独的数代表最小代价. 样例输入454430 2 2 22 0 3 32 3 0 42 3 4 0 样例输出9 输出详解： Farmer John在第四块土地上建立水库，然后把其他的都连向那一个，这样就要花费3+2+2+2=9 思路建造水库可以看作是在0位置有个有水的土地，该点到其它点的花费就是其它点自己建造水库的费用，然后跑最小生成树就行。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;#define FOR(i, a, b) for (int i=a; i&lt;(b); i++)#define F0R(i, a) for (int i=0; i&lt;(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i &gt;= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i &gt;= 0; i--)#define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()const int MAX_N = 100010;struct Edge &#123; int x, y, c; bool operator &lt; (const Edge&amp; e) const &#123; return c &lt; e.c; &#125;&#125;ed[MAX_N];int n;int par[310];void init(int n) &#123; FOR(i, 0, n+1) par[i]=i; &#125;int fa(int x) &#123; return x == par[x] ? x : par[x] = fa(par[x]); &#125;int nx = 0;void add_edge(int u, int v, int c) &#123; ed[nx].x = u; ed[nx].y = v; ed[nx].c = c; nx++; &#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d\", &amp;n)) &#123; nx = 0; init(n); FOR (i, 1, n+1) &#123; int tmp; scanf(\"%d\", &amp;tmp); add_edge(0, i, tmp); &#125; FOR(i, 1, n+1) &#123; FOR(j, 1, n+1) &#123; int tmp; scanf(\"%d\", &amp;tmp); if (j &lt; i) add_edge(i, j, tmp); &#125; &#125; sort(ed, ed+nx); int ans = 0; FOR(i, 0, nx) &#123; if (fa(ed[i].x) != fa(ed[i].y)) &#123; par[fa(ed[i].x)] = fa(ed[i].y); ans += ed[i].c; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","path":"2018/04/11/18-e5-b9-b44-e6-9c-88-e4-bb-bdbzoj-e5-88-b7-e9-a2-98-e8-ae-b0-e5-bd-95/","date":"04-11","excerpt":"","tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"/tags/BZOJ/"},{"name":"kruskal","slug":"kruskal","permalink":"/tags/kruskal/"},{"name":"mst","slug":"mst","permalink":"/tags/mst/"}]},{"title":"cf474 div1+div2","text":"A. Check the string 题意：给一个字符串的尾端加连续的‘a’，‘b’，‘c’字母，要求字符串按字典序排列，‘c’的数量要和‘a’，‘b’数量一样，‘a’和‘b’的数量大于等于1。 思路：计数即可，特别判断一下‘a’，‘b’的数量是否大于1。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# include &lt;stdio.h&gt;# include &lt;algorithm&gt;# include &lt;assert.h&gt;# include &lt;bitset&gt;# include &lt;cmath&gt;# include &lt;complex&gt;# include &lt;deque&gt;# include &lt;functional&gt;# include &lt;iostream&gt;# include &lt;limits.h&gt;# include &lt;map&gt;# include &lt;math.h&gt;# include &lt;queue&gt;# include &lt;set&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;string&gt;# include &lt;time.h&gt;# include &lt;unordered_map&gt;# include &lt;unordered_set&gt;# include &lt;vector&gt;# pragma warning(disable:4996)# pragma comment(linker, \"/STACK:336777216\")using namespace std;# define mp make_pair# define all(x) (x).begin(), (x).end()# define ldb ldoubletypedef tuple&lt;int, int, int&gt; t3;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef long double ldb;typedef pair &lt;int, int&gt; pii;typedef pair &lt;ll, ll&gt; pll;typedef pair &lt;ll, int&gt; pli;typedef pair &lt;db, db&gt; pdd;int IT_MAX = 1 &lt;&lt; 17;ll MOD = 998244353;const int INF = 0x3f3f3f3f;const ll LL_INF = 0x3f3f3f3f3f3f3f3f;const db PI = acos(-1);const db ERR = 1e-10;# define szz(x) (int)(x).size()# define rep(i, n) for(int i=0;i&lt;n;i++)# define Se second# define Fi firstconst int MAX_N = 5010;char s\\[MAX_N\\];int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%s\", s)) &#123; int len = strlen(s); bool flag = true; int cnt\\[3\\]; memset(cnt, 0, sizeof(cnt)); for (int i = 0; i &lt; len; i++) &#123; for (int j = s\\[i\\]-'a' + 1; j &lt; 3; j++) &#123; if (cnt\\[j\\] &gt; 0) &#123; flag = false; break; &#125; &#125; cnt\\[s\\[i\\]-'a'\\]++; &#125; if (!flag) printf(\"NO\\\\n\"); else &#123; if (cnt\\[2\\] == 0 || cnt\\[1\\] == 0 || cnt\\[0\\] == 0) &#123; printf(\"NO\\\\n\"); &#125; else if (cnt\\[2\\] == cnt\\[1\\] || cnt\\[2\\] == cnt\\[0\\]) &#123; printf(\"YES\\\\n\"); &#125; else &#123; printf(\"NO\\\\n\"); &#125; &#125; &#125; return 0;&#125; B. Minimize the error 题意：给两个长度为n的数列A，B，现在有一种操作是让数列中的一个数加一或者减一，可以对A做[latex]k{1}[/latex]次，对B做[latex]k{2}[/latex]次，现在定义一个数列[latex]E=\\sum{i=1}^{n}(a{i}-b_{i})^2[/latex]，问E的最小值是多少。 思路：先把A和B的差数列求出来并取绝对值，然后我们操作k1+k2次每次让最大的值减一取绝对值，操作完后计算E就是最小的。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# include &lt;stdio.h&gt;# include &lt;algorithm&gt;# include &lt;assert.h&gt;# include &lt;bitset&gt;# include &lt;cmath&gt;# include &lt;complex&gt;# include &lt;deque&gt;# include &lt;functional&gt;# include &lt;iostream&gt;# include &lt;limits.h&gt;# include &lt;map&gt;# include &lt;math.h&gt;# include &lt;queue&gt;# include &lt;set&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;string&gt;# include &lt;time.h&gt;# include &lt;unordered_map&gt;# include &lt;unordered_set&gt;# include &lt;vector&gt;# pragma warning(disable:4996)# pragma comment(linker, \"/STACK:336777216\")using namespace std;# define mp make_pair# define all(x) (x).begin(), (x).end()# define ldb ldoubletypedef tuple&lt;int, int, int&gt; t3;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef long double ldb;typedef pair &lt;int, int&gt; pii;typedef pair &lt;ll, ll&gt; pll;typedef pair &lt;ll, int&gt; pli;typedef pair &lt;db, db&gt; pdd;int IT_MAX = 1 &lt;&lt; 17;ll MOD = 998244353;const int INF = 0x3f3f3f3f;const ll LL_INF = 0x3f3f3f3f3f3f3f3f;const db PI = acos(-1);const db ERR = 1e-10;# define szz(x) (int)(x).size()# define rep(i, n) for(int i=0;i&lt;n;i++)# define Se second# define Fi firstconst int MAX_N = 1000010;int n;ll a\\[MAX_N\\];ll b\\[MAX_N\\];int k1, k2;ll ans;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d %d %d\", &amp;n, &amp;k1, &amp;k2)) &#123; ans = 0; rep(i, n) scanf(\"%lld\", &amp;a\\[i\\]); rep(i, n) scanf(\"%lld\", &amp;b\\[i\\]); priority_queue&lt;ll&gt; pq; rep(i, n) pq.push(abs(a\\[i\\]-b\\[i\\])); rep(i, k1+k2) &#123; ll t = pq.top(); pq.pop(); t--; pq.push(abs(t)); &#125; while (!pq.empty()) &#123; ll t = pq.top(); pq.pop(); ans += t * t; &#125; printf(\"%lld\\\\n\", ans); &#125; return 0;&#125; C. Subsequence Counting 题意：构造一个数列，使得这个数列满足去掉所有最大值减最小值的差大于等于d的子序列剩下的子序列数量为X。 思路：长度为n的序列的非空子序列为[latex]2^n-1[/latex]，把X看作一个二进制数若i位为1就可以看作是长度为i的合法子序列加上一个单一的序列。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# include &lt;stdio.h&gt;# include &lt;algorithm&gt;# include &lt;assert.h&gt;# include &lt;bitset&gt;# include &lt;cmath&gt;# include &lt;complex&gt;# include &lt;deque&gt;# include &lt;functional&gt;# include &lt;iostream&gt;# include &lt;limits.h&gt;# include &lt;map&gt;# include &lt;math.h&gt;# include &lt;queue&gt;# include &lt;set&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;string&gt;# include &lt;time.h&gt;# include &lt;unordered_map&gt;# include &lt;unordered_set&gt;# include &lt;vector&gt;# pragma warning(disable:4996)# pragma comment(linker, \"/STACK:336777216\")using namespace std;# define mp make_pair# define all(x) (x).begin(), (x).end()# define ldb ldoubletypedef tuple&lt;int, int, int&gt; t3;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef long double ldb;typedef pair &lt;int, int&gt; pii;typedef pair &lt;ll, ll&gt; pll;typedef pair &lt;ll, int&gt; pli;typedef pair &lt;db, db&gt; pdd;int IT_MAX = 1 &lt;&lt; 17;ll MOD = 998244353;const int INF = 0x3f3f3f3f;const ll LL_INF = 0x3f3f3f3f3f3f3f3f;const db PI = acos(-1);const db ERR = 1e-10;# define szz(x) (int)(x).size()# define rep(i, n) for(int i=0;i&lt;n;i++)# define Se second# define Fi firstconst int MAX_N = 10100;int X;ll d;ll ans\\[MAX_N\\];int n;void solve() &#123; n = 0; ll tmp = 1; int cnt = 1; int cnt_one = 0; while (X) &#123; if (X &amp; 1) &#123; cnt_one++; for (int i = 0; i &lt; cnt-1; i++) &#123; ans\\[n++\\] = tmp; if (n &gt; 10000) &#123; printf(\"-1\\\\n\"); return ; &#125; &#125; tmp += d; &#125; cnt++; X &gt;&gt;= 1; &#125; for (int i = 0; i &lt; cnt_one; i++) &#123; ans\\[n++\\] = tmp; if (n &gt; 10000) &#123; printf(\"-1\\\\n\"); return ; &#125; tmp += d; &#125; printf(\"%d\\\\n\", n); for (int i = 0; i &lt; n; i++) &#123; if (i &gt; 0) printf(\" \"); printf(\"%lld\", ans\\[i\\]); &#125; printf(\"\\\\n\");&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d %lld\", &amp;X, &amp;d)) &#123; solve(); &#125; return 0;&#125; D. Full Binary Tree Queries 题意：有一个无穷大的满二叉树，从根开始从1开始编号，现有3种操作 指定一个节点X，使得和X同一层的所有节点向右移动k个单位。 指定一个节点X，使得和X同一层的所有子树向右移动k个单位。 指定一个节点X，打印X到根的路径。 思路：统计每一个深度做了多少次1操作和2操作，可以计算出每次操作后当前值的位置，然后不断重复。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;using namespace std;typedef long long ll;int Q;int T;ll x, k;ll cnt1\\[65\\], cnt2\\[65\\];int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d\", &amp;Q)) &#123; memset(cnt1, 0, sizeof(cnt1)); memset(cnt2, 0, sizeof(cnt2)); while (Q--) &#123; scanf(\"%d\", &amp;T); if (T == 1) &#123; scanf(\"%lld %lld\", &amp;x, &amp;k); int dep = 0; while (x) &#123; x &gt;&gt;= 1; dep++; &#125; ll mod = 1LL &lt;&lt; (dep - 1); cnt1\\[dep\\] = ((cnt1\\[dep\\] + k) % mod + mod) % mod; &#125; else if (T == 2) &#123; scanf(\"%lld %lld\", &amp;x, &amp;k); int dep = 0; while (x) &#123; x &gt;&gt;= 1; dep++; &#125; ll mod = 1LL &lt;&lt; (dep - 1); cnt2\\[dep\\] = ((cnt2\\[dep\\] + k) % mod + mod) % mod; &#125; else &#123; scanf(\"%lld\", &amp;x); ll tmp = x; int dep = 0; while (tmp) &#123; tmp &gt;&gt;= 1; dep++; &#125; printf(\"%lld\", x); ll sz = 1LL &lt;&lt; (dep - 1); ll sum = (cnt1\\[dep\\] + cnt2\\[dep\\]) % sz; x = x + sum; if (x &gt; ((1LL&lt;&lt;(dep))-1)) x -= sz; x &gt;&gt;= 1; dep--; while (dep) &#123; ll sz = 1LL &lt;&lt; (dep-1); x = x + sz - cnt1\\[dep\\]; if (x &gt; ((1LL&lt;&lt;(dep))-1)) x -= sz; printf(\" %lld\", x); ll sum = (cnt1\\[dep\\]+cnt2\\[dep\\]) % sz; x = x + sum; if (x &gt; ((1LL&lt;&lt;(dep))-1)) x -= sz; x &gt;&gt;= 1; dep--; &#125; printf(\"\\\\n\"); &#125; &#125;&#125;return 0;&#125;","path":"2018/04/09/cf474-div1div2/","date":"04-09","excerpt":"","tags":[{"name":"思维","slug":"思维","permalink":"/tags/思维/"},{"name":"贪心","slug":"贪心","permalink":"/tags/贪心/"},{"name":"构造","slug":"构造","permalink":"/tags/构造/"}]},{"title":"Wannafly挑战赛13","text":"A. zzy的小号 题意：又到了打wannafly的时候，许许多多的大佬准备注册小号开始虐场，zzy也不例外，他发现他的电脑的字体有一个特点！某些不同的字符所显示的是一样的！ 满足以下四种情况之一，所显示的字符是一样的 1、两个字符互为英文字母的大小写 2、大写的’i’和小写的’l’ 3、大写的’o’和数字’0’ 4、基于前三种情况，三个字符a,b,c，如果a和b显示相同，b和c显示相同，那么a和c显示也是相同的 珂学家zzy想知道，对于一个他看起来相同的昵称，有多少个看起来一样的昵称 两个字符串看起來一样当且仅当长度一样且每个对应的位置的字符看起來一样 思路：数字只有‘0’有3种情况其它均为1种，字母‘i’，‘l’有4种情况，字母‘o’有3种情况其余均为2种。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;assert.h&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;#include &lt;map&gt;#include &lt;math.h&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;time.h&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;vector&gt; #pragma warning(disable:4996)#pragma comment(linker, \"/STACK:336777216\")using namespace std; #define mp make_pair#define all(x) (x).begin(), (x).end()#define ldb ldouble typedef tuple&lt;int, int, int&gt; t3;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef long double ldb;typedef pair &lt;int, int&gt; pii;typedef pair &lt;ll, ll&gt; pll;typedef pair &lt;ll, int&gt; pli;typedef pair &lt;db, db&gt; pdd; int IT_MAX = 1 &lt;&lt; 17;ll MOD = 1000000007;const int INF = 0x3f3f3f3f;const ll LL_INF = 0x3f3f3f3f3f3f3f3f;const db PI = acos(-1);const db ERR = 1e-10;#define szz(x) (int)(x).size()#define rep(i, n) for(int i=0;i&lt;n;i++)#define Se second#define Fi first const int MAX_N = 100010;char s[MAX_N];int len; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%s\", s)) &#123; ll ans = 1; len = strlen(s); rep(i, len) &#123; if (isdigit(s[i])) &#123; if (s[i] == '0') &#123; ans *= 3; ans %= MOD; &#125; else &#123; ans *= 1; &#125; &#125; else &#123; if (s[i] == 'o' || s[i] == 'O') &#123; ans *= 3; ans %= MOD; &#125; else if (s[i] == 'i' || s[i] == 'I' || s[i] == 'l' || s[i] == 'L') &#123; ans *= 4; ans %= MOD; &#125; else &#123; ans *= 2; ans %= MOD; &#125; &#125; &#125; printf(\"%lld\\n\", ans % MOD); &#125; return 0;&#125; B. Jxc军训 题意：Jxc将天空看做一个n*n的矩阵，此时天上有m朵云，这些云会随机分布在m个不同的位置，同时太阳会随机出现在一个位置，Jxc想知道他被太阳晒到的概率是多少，由于他仍在站军姿，所以这个有趣的问题就交给了你。考虑到精度问题，Jxc只需要知道这个概率在对998244353取模意义下的值。 Tips：一个分数p/q在模意义下的值即p*q-1在模意义下的值，Xp-11 (mod p) 思路：概率为[latex]\\frac{n^{2}-m}{n^{2}}[/latex],快速幂求个逆元即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;assert.h&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;#include &lt;map&gt;#include &lt;math.h&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;time.h&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;vector&gt; #pragma warning(disable:4996)#pragma comment(linker, \"/STACK:336777216\")using namespace std; #define mp make_pair#define all(x) (x).begin(), (x).end()#define ldb ldouble typedef tuple&lt;int, int, int&gt; t3;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef long double ldb;typedef pair &lt;int, int&gt; pii;typedef pair &lt;ll, ll&gt; pll;typedef pair &lt;ll, int&gt; pli;typedef pair &lt;db, db&gt; pdd; int IT_MAX = 1 &lt;&lt; 17;ll MOD = 998244353;const int INF = 0x3f3f3f3f;const ll LL_INF = 0x3f3f3f3f3f3f3f3f;const db PI = acos(-1);const db ERR = 1e-10;#define szz(x) (int)(x).size()#define rep(i, n) for(int i=0;i&lt;n;i++)#define Se second#define Fi firstll pow_mod(ll x, ll n, ll mod) &#123; //快速幂 ll res = 1; while (n &gt; 0) &#123; if (n &amp; 1) res = res * x % mod; x = x * x % mod; n &gt;&gt;= 1; &#125; return res;&#125; ll n, m; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (cin &gt;&gt; n &gt;&gt; m) &#123; ll p = n * n - m; ll q = n * n; ll t = pow_mod(q, MOD-2, MOD); cout &lt;&lt; ((p * t )% MOD) &lt;&lt; endl; &#125; return 0;&#125; C. zzf的好矩阵 题意：一个8 8的棋盘，第一个格子放1个麦穗，第二个格子放2个麦穗，第三个格子放4个麦穗……那么最后，共要放几个麦穗呢？ zzf表示这个问题实在太简单，于是重新规定了游戏的规则。 初始的棋盘为空，棋盘大小为p\\p，然后他要对棋盘进行若干次操作，可以被选择的操作如下： 1、选择一行，每个格子再放一个麦穗 2、选择一列，每个格子再放一个麦穗 进行若干次操作后，如果得到的棋盘满足如下性质 1、每个格子都有至少一个麦穗 2、每个格子最多只能有p*p个麦穗 3、任意两个格子的麦穗数不同 如果满足以上三条，那么称这个棋盘是一个好棋盘，若只是构造一个好棋盘那就太没意思了，zzf想知道他能得到多少个不同的好矩阵 定义不同的矩阵即只要存在一个位置不同即是不同的 答案对998244353取模 思路：答案为[latex]2*(A_p^p)^{2}[/latex] 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;assert.h&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;limits.h&gt;#include &lt;map&gt;#include &lt;math.h&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;time.h&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;vector&gt; #pragma warning(disable:4996)#pragma comment(linker, \"/STACK:336777216\")using namespace std; #define mp make_pair#define all(x) (x).begin(), (x).end()#define ldb ldouble typedef tuple&lt;int, int, int&gt; t3;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef long double ldb;typedef pair &lt;int, int&gt; pii;typedef pair &lt;ll, ll&gt; pll;typedef pair &lt;ll, int&gt; pli;typedef pair &lt;db, db&gt; pdd; int IT_MAX = 1 &lt;&lt; 17;ll MOD = 998244353;const int INF = 0x3f3f3f3f;const ll LL_INF = 0x3f3f3f3f3f3f3f3f;const db PI = acos(-1);const db ERR = 1e-10;#define szz(x) (int)(x).size()#define rep(i, n) for(int i=0;i&lt;n;i++)#define Se second#define Fi first ll P(ll n, ll m) &#123; ll res = 1; for (ll i = 0; i &lt; m; i++) &#123; res *= n; res %= MOD; n--; &#125; return res;&#125; int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); ll n; while (cin &gt;&gt; n) &#123; ll t = P(n, n); cout &lt;&lt; (2 * t * t) % MOD &lt;&lt; endl; &#125; return 0;&#125;","path":"2018/04/07/wannafly-e6-8c-91-e6-88-98-e8-b5-9b13/","date":"04-07","excerpt":"","tags":[{"name":"快速幂","slug":"快速幂","permalink":"/tags/快速幂/"},{"name":"组合数学","slug":"组合数学","permalink":"/tags/组合数学/"},{"name":"逆元","slug":"逆元","permalink":"/tags/逆元/"}]},{"title":"cf471 div2","text":"A. Feed the cat 题意：给一个当前时间，当前的饥饿值，每分钟饥饿值增加多少，一个面包能减少多少饥饿值，每个面包多少钱，在商店20:00之后面包打折20%，问最少花多少钱能把饥饿值减少到小于等于0. 思路：当前时间大于等于20:00直接算，小于就两种情况比较一下即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;cctype&gt;# include &lt;cmath&gt;# include &lt;vector&gt;using namespace std;typedef long long ll;int hh, mm;int H, D, C, N;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (cin &gt;&gt; hh &gt;&gt; mm) &#123; cin &gt;&gt; H &gt;&gt; D &gt;&gt; C &gt;&gt; N; double ans; if (hh &gt;= 20) &#123; ans = ceil(H * 1.0 / (N)) * C * 0.8; &#125; else &#123; int dir = 20 * 60 - (hh * 60 + mm); ans = ceil((H * 1.0 + dir * D) / (N)) * C * 0.8; ans = min(ans, ceil((H) * 1.0 / (N)) * C * 1.0); &#125; printf(\"%.4lf\\\\n\", ans); &#125; return 0;&#125; B. Not simply beatiful strings 题意：定义漂亮字符串是可以被分成两组子序列，这两组字符串分别由两个不同的字符组成。现给一个字符串任意调换字符顺序问能否分成两个漂亮字符串。 思路：字符种类等于1或大于4肯定不行，字符种类等于2的只有当两种字符数量都大于等于2才行，字符种类等于3的只要有至少一个字符数量大于等于2即可，字符种类等于4的必定可以。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;cctype&gt;# include &lt;cmath&gt;# include &lt;vector&gt;# include &lt;map&gt;using namespace std;typedef long long ll;const int MAX_N = 1e5+10;char s\\[MAX_N\\];int len;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%s\", s)) &#123; len = strlen(s); map&lt;char, int&gt; mp; for (int i = 0; i &lt; len; i++) &#123; mp\\[s\\[i\\]-'a'\\]++; &#125; if (mp.size() &gt; 4) printf(\"No\\\\n\"); else if (mp.size() &lt;= 1) printf(\"No\\\\n\"); else &#123; int cnt = 0; for (auto it = mp.begin(); it != mp.end(); it++) &#123; if (it -&gt; second &gt;= 2) cnt++; &#125; if (mp.size() == 2) &#123; if (cnt &gt;= 2) &#123; printf(\"Yes\\\\n\"); &#125; else &#123; printf(\"No\\\\n\"); &#125; &#125; else if (mp.size() == 3) &#123; if (cnt &gt;= 1) printf(\"Yes\\\\n\"); else printf(\"No\\\\n\"); &#125; else if (mp.size() == 4) &#123; printf(\"Yes\\\\n\"); &#125; &#125; &#125; return 0;&#125; C. Sad powers 题意：给一个区间[L, R]，问这个区间里面有多少个数的质因子唯一即[latex]x=a^{p}[/latex]。 思路：打表计算以2—1e6为底的奇数次幂然后二分一下得到奇数次幂的结果然后再加上次方的数量即可，次方可以直接计算sqrt(n)得到。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;cctype&gt;# include &lt;cmath&gt;# include &lt;vector&gt;# include &lt;map&gt;using namespace std;typedef long long ll;int N; ll L, R;vector&lt;ll&gt; st;vector&lt;ll&gt; vec;bool isQ(ll x) &#123; ll t = sqrt(x); return t * t == x;&#125;void pre() &#123; st.clear(); for (ll i = 2; i &lt; 1000001; i++) &#123; if (!isQ(i)) &#123; ll d2 = i * i; ll d3 = i * i * i; st.push_back(d3); while (d3 * 1.0 * d2 &lt;= 1e18) &#123; d3 *= d2; st.push_back(d3); &#125; &#125; &#125; sort(st.begin(), st.end()); st.erase(unique(st.begin(), st.end()), st.end());&#125;int solve(ll x) &#123; if (x == 0) return 0; ll res = upper_bound(st.begin(), st.end(), x) - st.begin(); res += (ll)sqrt(x); return res;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); pre(); while (~scanf(\"%d\", &amp;N)) &#123; while (N--) &#123; scanf(\"%lld %lld\", &amp;L, &amp;R); printf(\"%d\\\\n\", solve(R) - solve(L-1)); &#125; &#125; return 0;&#125;","path":"2018/04/04/cf471-div2/","date":"04-04","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"/tags/数论/"},{"name":"二分","slug":"二分","permalink":"/tags/二分/"},{"name":"打表","slug":"打表","permalink":"/tags/打表/"},{"name":"找规律","slug":"找规律","permalink":"/tags/找规律/"}]},{"title":"cf472 div2","text":"A. Tritonic Iridescence 题意：给一个字符串，字符串中包含4中字符，“C”，“Y”，“M”，“？”。“？”可以被替换成其它3种中的任意一种，现在问是否存在2种或2种以上的替换方式使得该字符串种任意两个相邻的字符不同。 思路： 使用dp的方式，用一个维度表示字符串长度，再用一个维度表示字符串的结尾dp记录替换的方式的数量，由于字符串长度较长若“？”比较多的话可能会爆longlong，题目只要求问是否大于等于两种我们统一把超过2的当作2即可。转移方程如下：[latex]\\left\\{\\begin{matrix}dp[i+1][0] = dp[i][1] + dp[i][2]\\\\ dp[i+1][1] = dp[i][0] + dp[i][2] \\\\ dp[i+1][2] = dp[i][0] + dp[i][1]\\end{matrix}\\right.[/latex] 存在两个确定连续相同的字符串输出No，“？”不在首尾且所有“？”两边的字符不同输出No，其它都输出Yes。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;cctype&gt;# include &lt;cmath&gt;# include &lt;vector&gt;using namespace std;typedef long long ll;const int MOD = 1e9;const int MAX_N = 110;char s\\[MAX_N\\];ll dp\\[MAX_N\\]\\[4\\];int n;int Hash(char c) &#123; if (c == 'C') return 0; if (c == 'M') return 1; return 2;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d\", &amp;n)) &#123; scanf(\"%s\", s); memset(dp, 0, sizeof(dp)); if (s\\[0\\] == '?') &#123; dp\\[1\\]\\[0\\] = dp\\[1\\]\\[1\\] = dp\\[1\\]\\[2\\] = 1; &#125; else &#123; dp\\[1\\]\\[Hash(s\\[0\\])\\] = 1; &#125; for (int i = 1; i &lt; n; i++) &#123; if (s\\[i\\] == '?') &#123; dp\\[i+1\\]\\[0\\] = dp\\[i\\]\\[1\\] + dp\\[i\\]\\[2\\]; dp\\[i+1\\]\\[1\\] = dp\\[i\\]\\[0\\] + dp\\[i\\]\\[2\\]; dp\\[i+1\\]\\[2\\] = dp\\[i\\]\\[0\\] + dp\\[i\\]\\[1\\]; if (dp\\[i+1\\]\\[0\\] &gt;= 2) dp\\[i+1\\]\\[0\\] = 2; if (dp\\[i+1\\]\\[1\\] &gt;= 2) dp\\[i+1\\]\\[1\\] = 2; if (dp\\[i+1\\]\\[2\\] &gt;= 2) dp\\[i+1\\]\\[2\\] = 2; &#125; else &#123; for (int j = 0; j &lt; 3; j++) &#123; if (j != Hash(s\\[i\\])) &#123; dp\\[i+1\\]\\[Hash(s\\[i\\])\\] += dp\\[i\\]\\[j\\]; &#125; if (dp\\[i+1\\]\\[Hash(s\\[i\\])\\] &gt;= 2) dp\\[i+1\\]\\[Hash(s\\[i\\])\\] = 2; &#125; &#125; &#125; if (s\\[n-1\\] == '?') &#123; if (dp\\[n\\]\\[0\\] + dp\\[n\\]\\[1\\] + dp\\[n\\]\\[2\\] &gt;= 2) &#123; printf(\"Yes\\\\n\"); &#125; else &#123; printf(\"No\\\\n\"); &#125; &#125; else &#123; if (dp\\[n\\]\\[Hash(s\\[n-1\\])\\] &gt;= 2) &#123; printf(\"Yes\\\\n\"); &#125; else &#123; printf(\"No\\\\n\"); &#125; &#125; &#125; return 0;&#125; B. Mystical Mosaic 题意：给一个n*m的矩阵，每个格子开始都是白色的，每次操作可以选取多行和多列，行列交叉的地方会被染成黑色，不可以重复选取行或列，给一个完成的矩阵，问能不能把全白的矩阵通过上述操作染成给定的矩阵。 思路：被染成黑色的格子可以表示其所在行和列必然是同时被选中的，那么我么可以先枚举所有黑色的格子，对每一个黑格子找到同一列上的黑格子，判断这两行的黑白格子是否完全一样，若出现不同则输出No，全部相同输出Yes。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;cctype&gt;# include &lt;cmath&gt;# include &lt;vector&gt;using namespace std;typedef long long ll;int n, m;string maze\\[51\\];bool vis\\[51\\];bool check() &#123; for (int i = 0; i &lt; n; i++) &#123; if (!vis\\[i\\]) &#123; vis\\[i\\] = true; string tmp = maze\\[i\\]; for (int j = 0; j &lt; m; j++) &#123; if (maze\\[i\\]\\[j\\] == '#') &#123; for (int k = 0; k &lt; n; k++) &#123; if (maze\\[k\\]\\[j\\] == '#') &#123; if (maze\\[k\\] != tmp) return false; &#125; &#125; &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (cin &gt;&gt; n &gt;&gt; m) &#123; memset(vis, false, sizeof(vis)); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; maze\\[i\\]; &#125; if (check()) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125; C. Three-level Laser 题意：给n个数和一个数U，从这n个数里面选3个数Ei, Ej, Ek, 满足（Ei &lt; Ej &lt; Ek &amp;&amp; (Ek - Ei) &lt;= U）使得[latex]\\eta =\\frac{E{k}-E{j}}{E{k}-E{i}}[/latex]最大 思路：Ej一定要尽可能小，Ek要尽可能大，枚举Ei可知j=i+1, 二分Ek即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;cctype&gt;# include &lt;cmath&gt;# include &lt;vector&gt;using namespace std;typedef long long ll;const int MAX_N = 100010;const double ESP = 1e-5;int n, U;int a\\[MAX_N\\];int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d %d\", &amp;n, &amp;U)) &#123; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a\\[i\\]); bool flag = false; double ans = 0.0; for (int i = 0; i &lt; n-2; i++) &#123; int ei = a\\[i\\]; int ej = a\\[i+1\\]; int p = upper_bound(a, a+n, a\\[i\\]+U)-a; if (p-1 &gt; i+1) &#123; flag = true; int ek = a\\[p-1\\]; double tmp = (double)(ek-ej) / (double)(ek-ei); ans = max(ans, tmp); &#125; &#125; if (flag) printf(\"%.9f\\\\n\", ans); else printf(\"-1\\\\n\"); &#125; return 0;&#125; D. Riverside Curio 题意：输入n代表n天，输入每一天看到的标记数量，每天会在海平面处加一个新的标记若已经加过了就不加，现在将每天在海平面以下的标记数加起来是的其总和最小并输出。 思路：设[latex]v{i}[/latex]表示第i天的标记数量，根据题意可以令[latex]v{i}=m{i}+d{i}+1[/latex]，则[latex]v{i}[/latex]必须满足 [latex]\\left\\{\\begin{matrix} v{i}\\geq v{i-1}\\\\ v{i}\\leq v{i-1}+1 \\end{matrix}\\right.[/latex] 当[latex]v{i-1}&gt;v{i}[/latex]时可以令[latex]d{i}=v{i-1}-v{i}[/latex]，当[latex]v{i}&gt;v{i-1}+1[/latex]时，另[latex]d{i-1}=v{i}-v_{i-1}-1[/latex] 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# include &lt;stdio.h&gt;# include &lt;algorithm&gt;# include &lt;assert.h&gt;# include &lt;bitset&gt;# include &lt;cmath&gt;# include &lt;complex&gt;# include &lt;deque&gt;# include &lt;functional&gt;# include &lt;iostream&gt;# include &lt;limits.h&gt;# include &lt;map&gt;# include &lt;math.h&gt;# include &lt;queue&gt;# include &lt;set&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;string&gt;# include &lt;time.h&gt;# include &lt;unordered_map&gt;# include &lt;unordered_set&gt;# include &lt;vector&gt;# pragma warning(disable:4996)# pragma comment(linker, \"/STACK:336777216\")using namespace std;# define mp make_pair# define all(x) (x).begin(), (x).end()# define ldb ldoubletypedef tuple&lt;int, int, int&gt; t3;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef long double ldb;typedef pair &lt;int, int&gt; pii;typedef pair &lt;ll, ll&gt; pll;typedef pair &lt;ll, int&gt; pli;typedef pair &lt;db, db&gt; pdd;int IT_MAX = 1 &lt;&lt; 17;int MOD = 1000000007;const int INF = 0x3f3f3f3f;const ll LL_INF = 0x3f3f3f3f3f3f3f3f;const db PI = acos(-1);const db ERR = 1e-10;# define szz(x) (int)(x).size()# define rep(i, n) for(int i=0;i&lt;n;i++)# define Se second# define Fi firstconst int MAX_N = 100010;int n;ll a\\[MAX_N\\];int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d\", &amp;n)) &#123; ll ans = 0; for (int i = 0; i &lt; n; i++) scanf(\"%lld\", &amp;a\\[i\\]); for (int i = 1; i &lt; n; i++) &#123; if (a\\[i-1\\] &gt; a\\[i\\]) &#123; ans += a\\[i-1\\] - a\\[i\\]; a\\[i\\] = a\\[i-1\\]; &#125; &#125; for (int i = n-1; i &gt; 0; i--) &#123; if (a\\[i-1\\] + 1 &lt; a\\[i\\]) &#123; ans += a\\[i\\] - a\\[i-1\\] - 1; a\\[i-1\\] = a\\[i\\] - 1; &#125; &#125; printf(\"%lld\\\\n\", ans); &#125; return 0;&#125;","path":"2018/04/03/cf472-div2/","date":"04-03","excerpt":"","tags":[{"name":"dp","slug":"dp","permalink":"/tags/dp/"},{"name":"脑洞","slug":"脑洞","permalink":"/tags/脑洞/"}]},{"title":"入门经典第三章题解","text":"翻译直接用了书上的 uva1585 Score 题意：给出一个由O和X组成的串，统计得分。每个O的得分为目前联系出现的O个数，X的得分为0。 思路：遍历一遍串，把每个O的得分加起来即可。 代码： 123456789101112131415161718192021222324252627282930313233# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;using namespace std;const int MAX_N = 1000;int N;char s\\[MAX_N\\];int main() &#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;N); while (N--) &#123; scanf(\"%s\", s); int len = strlen(s); int add = 0; int ans = 0; for (int i = 0; i &lt; len; i++) &#123; if (s\\[i\\] == 'O') &#123; add++; &#125; else &#123; add = 0; &#125; ans += add; &#125; printf(\"%d\\\\n\", ans); &#125; return 0;&#125; uva1586 Molar Mass 题意：给出一种物质的分子式，求分子量。 思路：题目给出的式子保证没有括号，那么只要考虑映射分子量以及把字符串数字转换成整数即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;map&gt;using namespace std;const int MAX_N = 1000;int N;char s\\[MAX_N\\];map&lt;char, double&gt; mp;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); mp\\['C'\\] = 12.01; mp\\['H'\\] = 1.008; mp\\['O'\\] = 16.00; mp\\['N'\\] = 14.01; scanf(\"%d\", &amp;N); while (N--) &#123; scanf(\"%s\", s); double ans = 0; double a = 0; int cnt = 0; for (int i = 0; s\\[i\\] != '\\\\0'; i++) &#123; if (isdigit(s\\[i\\])) &#123; cnt *= 10; cnt += s\\[i\\] - '0'; &#125; else &#123; ans += (cnt == 0 ? 1 : cnt) * a; a = mp\\[s\\[i\\]\\]; cnt = 0; &#125; &#125; ans += (cnt == 0 ? 1 : cnt) * a; printf(\"%.3lf\\\\n\", ans); &#125; return 0;&#125; uva1225 Digit Counting 题意：把前n个整数顺次写在一起，1234567891011…. 数一数0～9各出现多少次。 思路：由于n不大只有10000，可以直接循环计算。 代码： 12345678910111213141516171819202122232425262728293031323334353637# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;map&gt;using namespace std;const int MAX_N = 10;int N;int num;int cnt\\[MAX_N\\];int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;N); while (N--) &#123; memset(cnt, 0, sizeof(cnt)); scanf(\"%d\", &amp;num); for (int i = 1; i &lt;= num; i++) &#123; int tmp = i; while (tmp &gt; 0) &#123; cnt\\[tmp%10\\]++; tmp /= 10; &#125; &#125; printf(\"%d\", cnt\\[0\\]); for (int i = 1; i &lt;= 9; i++) &#123; printf(\" %d\", cnt\\[i\\]); &#125; printf(\"\\\\n\"); &#125; return 0;&#125; uva455 Periodic Strings 题意：输入一个字符串，输出它的最小周期。 思路：考虑kmp求最小循环节。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;using namespace std;const int MAX_N = 1000;int N;char p\\[MAX_N\\];int nxt\\[MAX_N\\];void kmpPre(char p\\[\\], int len, int nxt\\[\\]) &#123; int i, j; j = nxt\\[0\\] = -1; i = 0; while (i &lt; len) &#123; while (-1 != j &amp;&amp; p\\[i\\] != p\\[j\\]) j = nxt\\[j\\]; nxt\\[++i\\] = ++j; &#125;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i++) &#123; if (i &gt; 0) printf(\"\\\\n\"); scanf(\"%s\", p); int len = strlen(p); kmpPre(p, len, nxt); int ans = 0; if (len % (len - nxt\\[len\\]) == 0) &#123; ans = len - nxt\\[len\\]; &#125; else &#123; ans = len; &#125; printf(\"%d\\\\n\", ans); &#125; return 0;&#125; uva227 Puzzle 题意：有一个5*5的网格，一个格子是空的，其它格子都有一个唯一的字母，输入上下左右移动的指令，求最后网格的样子。 思路：纯模拟题。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;using namespace std;string puzzle\\[6\\];string cmd;int x, y;int kcase;void solve() &#123; cout &lt;&lt; \"Puzzle #\" &lt;&lt; ++kcase &lt;&lt; \":\" &lt;&lt; endl; getline(cin, cmd); int nx, ny; while (cmd\\[cmd.size() - 1\\] != '0') &#123; string cm; getline(cin, cm); cmd += cm; &#125; for (int i = 0; cmd\\[i\\] != '0'; i++) &#123; if (cmd\\[i\\] == 'A') &#123;nx = x - 1; ny = y;&#125; else if (cmd\\[i\\] == 'B') &#123;nx = x + 1; ny = y;&#125; else if (cmd\\[i\\] == 'L') &#123;nx = x; ny = y - 1;&#125; else if (cmd\\[i\\] == 'R') &#123;nx = x; ny = y + 1;&#125; if (0&lt;=nx&amp;&amp;nx&lt;5&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;5) &#123;swap(puzzle\\[x\\]\\[y\\], puzzle\\[nx\\]\\[ny\\]);&#125; else &#123; cout &lt;&lt; \"This puzzle has no final configuration.\" &lt;&lt; endl; return ; &#125; x = nx; y = ny; &#125; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; if (j &gt; 0) cout &lt;&lt; \" \"; cout &lt;&lt; puzzle\\[i\\]\\[j\\]; &#125; cout &lt;&lt; endl; &#125; return ;&#125;void init() &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; if (puzzle\\[i\\]\\[j\\] == ' ') &#123; x = i; y = j; return ; &#125; &#125; &#125;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); kcase = 0; while (true) &#123; for (int i = 0; i &lt; 5; i++) &#123; getline(cin, puzzle\\[i\\]); if (puzzle\\[i\\]\\[0\\] == 'Z') return 0; &#125; if (kcase &gt; 0) cout &lt;&lt; endl; init(); solve(); &#125; return 0;&#125; uva232 Crossword Answers 题意：输入一个r行c列的网格，黑格子用*表示，白格子里都会填一个字母，如果一个白格子的左边相邻位置或者上边相邻位置没有白格子，则称这个白格子是起始格。首先把所有起始格从上到下，从左到右编号，然后输出所有编号以及对应的横向和纵向的单词。 思路：先循环编号，然后横向循环以有编号的格子为起点输出单词，再纵向以有编号的格子为起点输出单词纵向循环输出的时候要把编号去掉。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;using namespace std;const int MAX_N = 15;int r, c;char maze\\[MAX\\_N\\]\\[MAX\\_N\\];int mark\\[MAX\\_N\\]\\[MAX\\_N\\];int kcase;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); kcase = 0; while (scanf(\"%d\", &amp;r) != EOF &amp;&amp; r != 0) &#123; int cnt = 0; scanf(\"%d\", &amp;c); if (++kcase &gt; 1) printf(\"\\\\n\"); printf(\"puzzle #%d:\\\\n\", kcase); for (int i = 0; i &lt; r; i++) &#123; scanf(\"%s\", maze\\[i\\]); &#125; memset(mark, 0, sizeof(mark)); for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; if (maze\\[i\\]\\[j\\] != '*') &#123; int dx1 = i; int dy1 = j - 1; int dx2 = i - 1; int dy2 = j; if ((dx1&lt;0||dy1&lt;0||dx2&lt;0||dy2&lt;0) || (maze\\[dx1\\]\\[dy1\\] == '*') || maze\\[dx2\\]\\[dy2\\] == '*') &#123; mark\\[i\\]\\[j\\] = ++cnt; &#125; &#125; &#125; &#125; printf(\"Across\\\\n\"); for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; if (mark\\[i\\]\\[j\\] &gt; 0) &#123; int dx = i; int dy = j; printf(\"%3d.\", mark\\[i\\]\\[j\\]); while (dy &lt; c &amp;&amp; maze\\[dx\\]\\[dy\\] != '*') &#123; printf(\"%c\", maze\\[dx\\]\\[dy\\]); dy++; &#125; printf(\"\\\\n\"); j = dy; &#125; &#125; &#125; printf(\"Down\\\\n\"); for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; if (mark\\[i\\]\\[j\\] &gt; 0) &#123; int dx = i; int dy = j; printf(\"%3d.\", mark\\[i\\]\\[j\\]); while (dx &lt; r &amp;&amp; maze\\[dx\\]\\[dy\\] != '*') &#123; printf(\"%c\", maze\\[dx\\]\\[dy\\]); mark\\[dx\\]\\[dy\\] = 0; dx++; &#125; printf(\"\\\\n\"); &#125; &#125; &#125; &#125; return 0;&#125; uva1368 DNA Consensus String 题意：输入m个长度为n的DNA序列，求一个DNA序列使得其到其它DNA序列的Hamming距离最小，并输出需要改变的次数。 思路：逐位遍历一下所有DNA序列看哪个字母数量最多便是最后得到的DNA序列。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;using namespace std;const int MAX_N = 1010;int T;int r, c;char maze\\[55\\]\\[MAX_N\\];int cnt\\[26\\];int mark;char ans\\[MAX_N\\];int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); scanf(\"%d\", &amp;T); while (T--) &#123; mark = 0; scanf(\"%d %d\", &amp;r, &amp;c); for (int i = 0; i &lt; r; i++) &#123; scanf(\"%s\", maze\\[i\\]); &#125; for (int i = 0; i &lt; c; i++) &#123; memset(cnt, 0, sizeof(cnt)); for (int j = 0; j &lt; r; j++) &#123; cnt\\[maze\\[j\\]\\[i\\] - 'A'\\]++; &#125; int tmp = 0; int ma = 0; for (int k = 0; k &lt; 26; k++) &#123; if (cnt\\[k\\] &gt; ma) &#123; ma = cnt\\[k\\]; tmp = k; &#125; &#125; ans\\[i\\] = tmp+'A'; for (int k = 0; k &lt; 26; k++) &#123; if (k != tmp) mark += cnt\\[k\\]; &#125; &#125; ans\\[c\\] = '\\\\0'; printf(\"%s\\\\n\", ans); printf(\"%d\\\\n\", mark); &#125; return 0;&#125; uva202 Repeating Decimals 题意：输入整数a和b，输出a/b的循环小数表示以及循环节长度。 思路：模拟除法，记下每次的商和余数，出现完全相同的时候就找到了循环节，细节看代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;using namespace std;const int MAX_N = 100000;int a, b, t, tmp;int ans\\[MAX_N\\];int res\\[MAX_N\\];void solve() &#123; int index = 0; while (true) &#123; tmp *= 10; ans\\[index\\] = (tmp / b); res\\[index\\] = tmp = (tmp % b); for (int i = 0; i &lt; index; i++) &#123; if (res\\[i\\] == res\\[index\\] &amp;&amp; ans\\[i\\] == ans\\[index\\]) &#123; for (int j = 0; j &lt; index; j++) &#123; if (j == i) printf(\"(\"); printf(\"%d\", ans\\[j\\]); if (j == index - 1) &#123; printf(\")\\\\n\"); printf(\" %d = number of digits in repeating cycle\\\\n\", (index - i)); return ; &#125; if (j - i + 1 &gt;= 50) &#123; printf(\"...)\\\\n\"); printf(\" %d = number of digits in repeating cycle\\\\n\", (index - i)); return ; &#125; &#125; &#125; &#125; index++; &#125;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%d %d\", &amp;a, &amp;b)) &#123; t = a / b; tmp = a % b; printf(\"%d/%d = %d.\", a, b, t); solve(); printf(\"\\\\n\"); &#125; return 0;&#125; uva10340 All in All 题意：输入两个字符串s和t，判断是否可以从t中删除0个或多个字符得到字符串s。 思路：遍历s和t即可，细节看代码。 代码： 123456789101112131415161718192021222324252627282930313233343536# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;cctype&gt;using namespace std;const int MAX_N = 1000100;char s\\[MAX\\_N\\], t\\[MAX\\_N\\];int lens, lent;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%s %s\", s, t)) &#123; lens = strlen(s); lent = strlen(t); int indexs = 0, indext = 0; bool flag = false; while (indexs &lt; lens) &#123; while (indext &lt; lent) &#123; if (s\\[indexs\\] == t\\[indext\\]) &#123; break; &#125; else &#123; indext++; &#125; &#125; if (indext &lt; lent) &#123; indexs++; indext++; &#125; else break; &#125; ​ if (indexs == lens) { printf(&quot;Yes\\\\n&quot;); } else { printf(&quot;No\\\\n&quot;); } }return 0;​12&#125; uva1587 Box 题意：给6个矩形的长和宽，判断他们能否构成长方体。 思路：能构成长方体，长和宽必然最多只有3个不同数，假设其为a,b,c。关系为a&lt;=b&lt;=c，那么我们对这6个矩形排序（假设长&lt;=宽）就能得到ab,ab,ac,ac,bc,bc。不满足的都是不能构成长方体的。 代码： 12345678910111213141516# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;cctype&gt;using namespace std;struct Rec &#123; int w, h;​ bool operator &lt; (const Rec&amp; rec) const { return w &lt; rec.w || (w == rec.w &amp;&amp; h &lt; rec.h);} bool operator == (const Rec&amp; rec) const { return w == rec.w &amp;&amp; h == rec.h;}​1234567891011121314151617181920212223242526&#125;;Rec rec\\[6\\];int main() &#123; // freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); int w, h; while (~scanf(&quot;%d %d&quot;, &amp;w, &amp;h)) &#123; rec\\[0\\].w = w; rec\\[0\\].h = h; if (rec\\[0\\].w &lt; rec\\[0\\].h) swap(rec\\[0\\].w, rec\\[0\\].h); for (int i = 1; i &lt; 6; i++) &#123; scanf(&quot;%d %d&quot;, &amp;rec\\[i\\].w, &amp;rec\\[i\\].h); if (rec\\[i\\].w &lt; rec\\[i\\].h) swap(rec\\[i\\].w, rec\\[i\\].h); &#125; sort(rec, rec + 6); if (rec\\[0\\] == rec\\[1\\] &amp;&amp; rec\\[2\\] == rec\\[3\\] &amp;&amp; rec\\[4\\] == rec\\[5\\]) &#123; if (rec\\[1\\].h == rec\\[2\\].h &amp;&amp; rec\\[3\\].w == rec\\[4\\].w &amp;&amp; rec\\[1\\].w == rec\\[4\\].h) printf(&quot;POSSIBLE\\\\n&quot;); else printf(&quot;IMPOSSIBLE\\\\n&quot;); &#125; else &#123; printf(&quot;IMPOSSIBLE\\\\n&quot;); &#125; &#125; return 0;&#125; uva1588 Kickdown 题意：给出两个长度分别为n1,n2且高度只为1或2的长条，需要将它们放入一个高度为3的容器，问能够容纳它们的最短容器长度。 思路：先以n1为底移动n2找最短长度，再以n2为底移动n1找最短长度，然后比较一下即可。细节看代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;cctype&gt;using namespace std;const int MAX_N = 110;char s1\\[MAX\\_N\\], s2\\[MAX\\_N\\];int len1, len2;int minLen(char s1\\[\\], char s2\\[\\], int len1, int len2) &#123; int res = 0; int ans = 100000; for (int i = 0; i &lt; len1; i++) &#123; bool flag = true; for (int j = 0; j &lt; len2; j++) &#123; if (i + j &gt;= len1) break; if ((s1\\[i+j\\]-'0') + (s2\\[j\\]-'0') &gt; 3) &#123; flag = false; break; &#125; &#125; if (flag) &#123; ans = min(ans, res + max(len1 - res, len2)); &#125; res++; &#125; return min(ans, len1+len2);&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); while (~scanf(\"%s %s\", s1, s2)) &#123; len1 = strlen(s1); len2 = strlen(s2); printf(\"%d\\\\n\", min(minLen(s1, s2, len1, len2), minLen(s2, s1, len2, len1))); &#125; return 0;&#125; uva11809 Floating-Point Numbers 题意：给出一个AeB格式的字符，输出对应的阶码尾数表示法的阶码的位数和尾数的位数。 思路：题目要求的误差小于10^(-5)，给定的位数比较小，我们可以先把所有阶码位数和尾数尾数的值打一个表，输出的时候直接查表即可。细节看代码。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# include &lt;iostream&gt;# include &lt;cstdio&gt;# include &lt;cstring&gt;# include &lt;algorithm&gt;# include &lt;cctype&gt;# include &lt;cmath&gt;using namespace std;typedef long long ll;const double EPS = 0.0001;char s\\[40\\];double M\\[11\\]\\[31\\];ll E\\[11\\]\\[31\\];double a;int b;void tab() &#123; for (int i = 0; i &lt; 10; i++) &#123; for (int j = 1; j &lt;= 30; j++) &#123; double m = 1 - pow(2, -1-i); double e = (1 &lt;&lt; j) - 1; double e10 = log10(m) + e * log10(2); E\\[i\\]\\[j\\] = (ll)e10; M\\[i\\]\\[j\\] = pow(10, e10 - E\\[i\\]\\[j\\]); &#125; &#125;&#125;void solve() &#123; for (int i = 0; i &lt; 10; i++) &#123; for (int j = 1; j &lt;= 30; j++) &#123; if (b == E\\[i\\]\\[j\\] &amp;&amp; fabs(a - M\\[i\\]\\[j\\]) &lt; EPS) &#123; printf(\"%d %d\\\\n\", i, j); return ; &#125; &#125; &#125;&#125;int main() &#123; // freopen(\"in.txt\", \"r\", stdin); // freopen(\"out.txt\", \"w\", stdout); tab(); while (cin.getline(s, 40)) &#123; if (strcmp(s, \"0e0\") == 0) break; char s1\\[40\\], s2\\[40\\]; sscanf(s, \"%\\[^e\\]\", s1); sscanf(s, \"%*\\[^e\\]e%s\", s2);​ a = stod(s1); b = stoi(s2); while (a &lt; 1) { a *= 10; b -= 1; } solve(); }return 0;​12&#125;","path":"2018/03/29/e5-85-a5-e9-97-a8-e7-bb-8f-e5-85-b8-e7-ac-ac-e4-b8-89-e7-ab-a0-e9-a2-98-e8-a7-a3/","date":"03-29","excerpt":"","tags":[{"name":"模拟","slug":"模拟","permalink":"/tags/模拟/"},{"name":"kmp","slug":"kmp","permalink":"/tags/kmp/"}]},{"title":"4年ACM的碎碎念","text":"从实习结束回到学校也有10来天来，如今大四的我不由得对即将结束的本科生活回想了一番。虽然将近4年的大学生活又喜又悲，但总的来讲我觉得遗憾还是太多太多了。 从大一入学开始我就决定要好好珍惜大学的时光，努力成为自己想成为的人。不过现在回想起来当初的想法虽好但缺少可行性，毕竟连自己想成为什么样的都不知道又谈什么成为自己希望的样子呢。当时的我认为大一的时候做职业规划是很扯淡的事情，4年的时间能改变的东西太多了，大一时候想做的事情未必是自己毕业时候想做的。我至今觉得这种想法是正确的。大一的时候我总觉得自己很厉害，成绩优秀，编程能力也强，各个方面做事都比周围的人要强一些，仿佛自己就是一个天选之人，这个世界都在围着我转。虽然现在看来当时的我眼界太小，如果那种程度都能算优秀的话，那这个社会恐怕要退步了吧。不过我觉得年少轻狂并不是坏事，至少比畏首畏尾要强那么一点。 在大一的时候接触到ACM，当时还是几个大二的学长学姐做了一个海报（其实就是几行字）宣传了一下，我就这么进了一个叫做ACM协会的组织。其实在进大学之前我就有搞ACM的打算，当时我只是觉得ACM竞赛好想很有逼格，因为在中学的时候接触到了数学竞赛，我也清楚搞数学竞赛的人都是如何地优秀，所以我想如果我要证明自己是优秀的那么我就要参加自己学科的最顶尖的竞赛并取得一个不错的成绩。刚进入协会的时候（当时并没有集训队的说法）只有一两个学长一个月上个一两次课，一周在vj上放几个题目大家写一写这种程度。当时学长们放的第一次比赛，我这个连C语言还没有学的菜鸟居然拿了个第一名（大概是因为其他人也和我一样都没学C语言），这极大地提高了我搞ACM的积极性，我当时似乎觉得如果我真的认真去比一定能取得很好的成绩。之后学长们放的比赛我每次都是第一，当时我为了保住第一的名次（其实这个第一没什么意义，就是满足了一下我的虚荣心而已）每天都在努力学习专业知识，有空就打开OJ刷刷题目，这种热情我保持了半个学期的时间。到了大一下学期开学的时候，我觉得社团里应该要弄些事情吧，比如讲讲课，比比赛什么的，然而失望的是在开学后的将近4个星期都没任何和ACM有关的安排，有的就是群里面大家没事扯一些怎么学c++啊，哪个老师怎么样这种无聊的事情，同时我还发现我之前所做的比赛（学长发布的），参加的人越来越少，这时我就有了危机感，因为ACM是3人一组的比赛，我找不到队友怎么办。到了学期中我实在忍不住在社团群里面抱怨了一番，大概就是“你们还想不想搞ACM了”，“开学以来没有一件和ACM有关的事”之类很直接的话。发完之后会长就单独和我聊了一下，大意就是“大家不积极，没有老师带，我也很无奈”这种。其实会长人挺不错的，看上去也很想搞ACM的，无奈环境就是不允许。我记得当天晚上会长还带我去网吧打了一场cf，貌似就做了一题，不过翻墙技能get。。大一快结束的时候会长突然和我说，大一还在搞ACM的就剩我一个人了，虽然比较早就隐隐约约有这种感觉，毕竟后面去听课，做题貌似还就真只有我一个了，不过当时听到这个消息的时候还是很难过的，毕竟没有队友我没有参加比赛的可能，学长们当时也就剩3个人了，也就能组一个队，我就落单了。其实在那天去网吧打完cf之后我就做了一个决定打算以后和新生组队，因为当时我觉得同届的人都太差了（当时太狂妄了，不过确实是我当时的真实想法），我想好好培养新一届的学生，这样我就可以组队了。 大二开学之后，训练室就剩下了我以及会长和他的室友，他们的另一个队友我经常看不到。大概两个星期之后吧，训练室又来了一个大一的新生hyc，他后面成为了我的队友。因为当时我们都没有宣传我都不知道他怎么加进来的，后面问了一下会长，会长说他是自己找来的，平时我们也偶尔会一起刷刷题目，我渐渐觉得他有点像大一时候的我（后面发现还是完全不像啊。。哈哈）。hyc刷题很努力，而且这个时候负责我们的老师也来了，这让我突然又有了比赛的信心，再之后和我同一届的同学又来了两个人lwl和pl，他们也是一开始就加入了ACM协会，只不过我一直没有见过他们，其中还有一个是我的同班同学（这侧面说明了我们这个组织有多么零散。。）。不过现在人数增加变成了7个人，学长们肯定会组一个队，剩下的我们4个人怎么组队就是问题，不过老师说让我们先不用考虑组队的问题，先把基础打好再说，我当时觉得挺对的，不过现在想来还是一开始把队伍定好比较好，毕竟一起训练的效率比较高。当时的我还是比较自负的吧，我其实比较喜欢一个人训练，可能是大一一直都是一个人训练的，习惯了，所有我没有带头组织其他3个人训练，还是一直保持着我大一时候的样子自己闷头训练，大二上末期学长们去沈阳icpc现场赛打了个铁，我当时完全不知道。。当时社团就那么几个人也没有谁负责统计大家的刷题情况，也没有平时的训练安排，我自己也松懈了不少，甚至有段时间我都忘了自己是ACM协会的成员，忘了自己最初想要在ACM中取得一个成绩的想法了，可能这就是所谓的温水煮青蛙吧，悠闲的大学生活和松懈的学习环境麻木了我，我算了一下大二一年下来的刷题量远远不如大一。 大二下的时候选了算法设计这门课，讲这课的老师刚好就是我们的教练，之前都没说说我们的教练。我们的教练也是第一次带我们ACM，学院之前都没有什么所谓的ACM参赛队，教练带我们也没有经验，不过我们教练人确实很好，我们想参加的比赛教练都会尽力为我们申请参赛名额和报销名额，可以说没有教练我大概早就放弃ACM了，当然我的队友也是，虽然之前一直说不信任同一届的同学，但没有他们我大概不会参赛吧。上课的时候我们教练也不忘时不时宣传一下ACM，我听着确实很感动，课我倒是没怎么听，毕竟在ACM协会2年了，我很想把它发展起来，但是自己组织能力不行，沟通能力不行，也没有管理经验，做什么都有点半吊子的确实心有余而力不足，不过我很后悔，现在我还在想如果当时我能主动一点去多拉一些人进来，学长们不上课我去上会是一个什么样的结果。经过教练一个学期的课下来又有挺多和我同一届的同学加了进来，当时的我是又有点开心又有点不信任他们的。可能我本来就是一个不太容易相信别人的人吧，在加上大一的时候新生只剩我一个这种阴影，我都没怎么和他们交流过，因为当时学长们还没退役，我也不是会长，我就把这事全丢给他们了，当然这是我的不对。可能是因为他们觉得没什么希望吧，新加的人很快就退了，不过他们之中还有两个女生和我之后的一个队友组了个女队参加了一次ccpc女生赛。。虽然最后打铁了，不过好歹能有参加的勇气就不错了。 大二的暑假可能是我大学中比较难忘的一段经历吧，当时学长们退役，我成为了协会会长，同时教练又招了几个大一的学弟进来，其中还有一个手脚不方便的学弟，我当时很佩服他的勇气，教练让我们暑假集训，并且由我来组织，当时的我一脸懵逼，不知道怎么下手，好在hyc参加过icpccamp知道他们的一些训练方式，当然大佬们的训练方式在我们这并没有什么参考性不过学了一些他们的作息安排。我们4个人商量了一下每个人负责讲的专题，每隔一个星期换一个人讲，然后排了一下讲课的时间和训练时间就和大一的学弟们说了一下，暑假开始后我们的集训也开始了，开始前lwl表示自己太弱不讲课，集训中pl因为身体原因大概就讲了一个星期吧，hyc好点讲了两个星期多的样子，剩下的除去多校比赛和自主训练外就都是我在讲课，说实话很累，自己基础本来就不好，还要边学边讲，有几次生病了还要继续备课还要带病讲。开始的时候学弟们还会认真听，课后的练习也完成的很好，但是到后期听的人越来越少，做课后练习的人也越来越少，就像我当年大一的时候的情况一样，我也渐渐地没有了带人兴趣，可能是因为我确实不够成熟，讲课也不好，总之没有尽到一个做会长的责任。多校的情况也可想而知，比的最好的貌似也就100多名吧，可能是因为我们让学弟们看不到希望吧，大三上结束的时候他们就全退了。。 大三的一年就很平淡了，就大三上的时候我参加了两场区预赛，教练对我还是很好的，不幸的是两场都打铁了。。。一场和hyc，pl组队，一场和前会长，lwl组队，总的来讲我确实要背锅，这两场比赛大概是我第一次试着主动尝试和人沟通的比赛（训练的时候其实我也是自己做自己的），当然其中还有一个小插曲，因为第二场其实原本不是前会长去比的，但是教练中途突然把pl换了，而且没有和她说，我觉得挺对不起她的。打完铁之后，我很不甘心于是又有了再打最后一年的打算。 大四开始决定考研，但是又想再打个半年，所有一边复习一边准备比赛，但是显然人的精力有限自己也不是那种自制力很强的人，于是放弃考研专心比赛（感觉是个比较蠢的决定）。训练也就只有自己训练没时间去管队友是否训练了，上半年我只有一场比赛的机会就是西安的区预赛，和hyc，pl组了个队拿了个铜，比较是学院的第一块牌个人还是比较开心的，放弃了那么多东西最后拿了个牌虽然是铜，但也算是自己参加ACM的证明了。 以后的打算，可能还是考研吧，超级想去一所顶尖的学校，其实我最想去的是CMU，但是我现在这种渣渣水平完全不够格啊。我记得我刚入学的时候想的事情是在自己还有激情和动力的时候做一番能流入史册的事情，实际上我完全没有什么未来的打算，我也不知道自己未来要做什么，不过我想如果能去一个优秀的人群集的地方我应该能找到自己的目标，虽然现在我已经大四了但是我也依然要保持刚入学时的激情，虽然大学4年满是遗憾但是能从其他的人那里学到很多的人生经验也算是对得起自己了。 最后祝愿自己能长成自己想要的样子。","path":"2018/03/19/4-e5-b9-b4acm-e7-9a-84-e7-a2-8e-e7-a2-8e-e5-bf-b5/","date":"03-19","excerpt":"","tags":[]},{"title":"开始记录博客啦","text":"实习结束回来感觉自己好弱，想开个博客记录一下每个时间段的成长，虽然以前也写过博客，但是租的服务器过期啦可惜以前刷题用的博客就这么没了，这个博客就用来记录自己的成长好啦，毕竟现在的我也不是只有ACM。 顺便测试一下。 代码： 12345678# include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; \"Hello World\" &lt;&lt; endl; return 0;&#125; 数学公式: $E=mc^2$","path":"2018/03/06/e5-bc-80-e5-a7-8b-e8-ae-b0-e5-bd-95-e5-8d-9a-e5-ae-a2-e5-95-a6/","date":"03-06","excerpt":"","tags":[]},{"title":"世界，您好！","text":"欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！","path":"2018/03/06/hello-world-1/","date":"03-06","excerpt":"","tags":[]}]}